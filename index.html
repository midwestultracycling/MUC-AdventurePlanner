<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RouteScout - Adventure Cycling Resource Planner</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- Mishigami Brand Colors -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-primary: #00417C;
      --color-primary-dark: #003366;
      --color-secondary: #6B2424;
      --color-secondary-light: #8B3434;
      --color-accent: #277521;
      --color-accent-light: #328A2A;
      --color-bg: #FFFBF8;
      --color-bg-alt: #F5F1EE;
      --color-text: #051829;
      --color-text-muted: #4A5568;
      --color-border: #E2DED9;
      --color-white: #FFFFFF;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--color-bg); color: var(--color-text); }

    .container { max-width: 1400px; margin: 0 auto; padding: 0 24px; }
    .card { background: var(--color-white); border-radius: 12px; box-shadow: 0 1px 3px rgba(5,24,41,0.08); }
    .btn { padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
    .btn-primary { background: var(--color-primary); color: white; }
    .btn-primary:hover { background: var(--color-primary-dark); }
    .btn-secondary { background: var(--color-bg-alt); color: var(--color-text); }
    .btn-secondary:hover { background: var(--color-border); }
    .btn-outline { background: transparent; border: 1px solid var(--color-border); color: var(--color-text); }
    .btn-outline:hover { background: var(--color-bg); border-color: var(--color-text-muted); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-sm { padding: 8px 16px; font-size: 13px; }
    .btn-xs { padding: 4px 10px; font-size: 12px; }

    header { padding: 16px 0; border-bottom: 1px solid var(--color-border); background: var(--color-white); position: sticky; top: 0; z-index: 100; }
    .header-content { display: flex; align-items: center; justify-content: space-between; }
    .logo { font-size: 22px; font-weight: 700; color: var(--color-primary); display: flex; align-items: center; gap: 10px; }
    .logo svg { width: 28px; height: 28px; }
    .header-actions { display: flex; gap: 12px; align-items: center; }

    .unit-toggle { display: flex; align-items: center; gap: 8px; background: var(--color-bg-alt); padding: 4px; border-radius: 8px; }
    .unit-toggle button { padding: 6px 12px; border: none; background: transparent; cursor: pointer; font-size: 13px; font-weight: 500; color: var(--color-text-muted); border-radius: 6px; transition: all 0.2s; }
    .unit-toggle button.active { background: var(--color-white); color: var(--color-text); box-shadow: 0 1px 3px rgba(5,24,41,0.1); }

    .input-section { padding: 40px 0; }
    .input-tabs { display: flex; gap: 4px; margin-bottom: 24px; background: var(--color-bg-alt); padding: 4px; border-radius: 10px; width: fit-content; }
    .input-tab { padding: 10px 20px; border: none; background: transparent; cursor: pointer; font-size: 14px; font-weight: 500; color: var(--color-text-muted); border-radius: 8px; transition: all 0.2s; }
    .input-tab.active { background: var(--color-white); color: var(--color-text); box-shadow: 0 1px 3px rgba(5,24,41,0.1); }

    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; font-size: 13px; font-weight: 500; color: var(--color-text-muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    .form-group input, .form-group select { width: 100%; padding: 14px 16px; border: 1px solid var(--color-border); border-radius: 8px; font-size: 15px; transition: border-color 0.2s; }
    .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--color-primary); }

    .file-drop { border: 2px dashed var(--color-border); border-radius: 12px; padding: 48px; text-align: center; cursor: pointer; transition: all 0.2s; background: var(--color-bg); }
    .file-drop:hover, .file-drop.dragover { border-color: var(--color-primary); background: #E8F0F8; }
    .file-drop-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }
    .file-drop h3 { font-size: 16px; margin-bottom: 8px; color: var(--color-text); }
    .file-drop p { color: var(--color-text-muted); font-size: 14px; }
    .file-drop input { display: none; }

    .url-input-group { display: flex; gap: 12px; }
    .url-input-group input { flex: 1; }

    .settings-row { display: flex; flex-wrap: wrap; gap: 16px; margin-bottom: 24px; padding-bottom: 24px; border-bottom: 1px solid var(--color-border); align-items: flex-end; }
    .settings-row .form-group { flex: 0 0 auto; margin-bottom: 0; }
    .settings-row input[type="date"],
    .settings-row input[type="time"],
    .settings-row input[type="number"],
    .settings-row select { height: 44px; padding: 0 12px; border: 1px solid var(--color-border); border-radius: 8px; font-size: 14px; width: auto; }
    .settings-row input[type="date"] { width: 150px; }
    .settings-row input[type="time"] { width: 120px; }
    .settings-row .speed-input-group input[type="number"] { width: 70px; }
    @media (max-width: 768px) { .settings-row { flex-direction: column; align-items: stretch; } .settings-row .form-group { width: 100%; } .settings-row input, .settings-row select { width: 100% !important; } }

    .map-container { height: 500px; border-radius: 12px; overflow: hidden; margin-bottom: 0; position: relative; }
    #map { height: 100%; width: 100%; }
    .map-legend { position: absolute; bottom: 20px; left: 20px; background: var(--color-white); padding: 12px 16px; border-radius: 8px; box-shadow: 0 2px 8px rgba(5,24,41,0.15); z-index: 1000; font-size: 12px; }
    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

    .elevation-profile { background: var(--color-white); border-radius: 0 0 12px 12px; padding: 16px; margin-bottom: 24px; border-top: 1px solid var(--color-border); }
    .elevation-profile h4 { font-size: 13px; font-weight: 600; color: var(--color-text); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .elevation-chart { position: relative; height: 120px; cursor: crosshair; }
    .elevation-canvas { width: 100%; height: 100%; }
    .elevation-tooltip { position: absolute; background: var(--color-text); color: white; padding: 6px 10px; border-radius: 6px; font-size: 12px; pointer-events: none; white-space: nowrap; transform: translateX(-50%); z-index: 10; }
    .elevation-hover-dot { position: absolute; width: 10px; height: 10px; background: var(--color-secondary); border: 2px solid white; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); box-shadow: 0 2px 4px rgba(5,24,41,0.3); z-index: 9; }
    .elevation-stats { display: flex; gap: 24px; margin-top: 12px; font-size: 12px; color: var(--color-text-muted); }
    .elevation-stats span { display: flex; align-items: center; gap: 4px; }

    .results-section { padding: 40px 0; }
    .results-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; flex-wrap: wrap; gap: 16px; }
    .results-tabs { display: flex; gap: 8px; }
    .tab { padding: 10px 20px; background: transparent; border: none; cursor: pointer; font-size: 14px; font-weight: 500; color: var(--color-text-muted); border-radius: 8px; transition: all 0.2s; }
    .tab.active { background: var(--color-primary); color: white; }
    .tab:hover:not(.active) { background: var(--color-bg-alt); }

    .timeline { position: relative; padding-left: 40px; }
    .timeline::before { content: ''; position: absolute; left: 15px; top: 0; bottom: 0; width: 2px; background: var(--color-border); }
    .timeline-item { position: relative; padding: 12px 0; }
    .timeline-item.planned-stop .timeline-content { background: #FFFBEB; border: 1px solid #F59E0B; }
    .timeline-marker { position: absolute; left: -33px; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; background: var(--color-white); border: 2px solid var(--color-border); }
    .timeline-marker.water { background: #E8F0F8; border-color: var(--color-primary); }
    .timeline-marker.camp { background: #E8F5E8; border-color: var(--color-accent); }
    .timeline-marker.food { background: #FFF8E8; border-color: #d97706; }
    .timeline-marker.scenic { background: #f3e8ff; border-color: #9333ea; }
    .timeline-marker.store { background: #ECFEFF; border-color: #0891B2; }
    .timeline-marker.start { background: var(--color-accent); border-color: var(--color-accent); color: white; }
    .timeline-marker.end { background: var(--color-secondary); border-color: var(--color-secondary); color: white; }

    .timeline-content { background: var(--color-white); padding: 14px 18px; border-radius: 10px; box-shadow: 0 1px 3px rgba(5,24,41,0.06); }
    .timeline-time { font-size: 12px; color: var(--color-text-muted); margin-bottom: 2px; font-weight: 500; }
    .timeline-title { font-weight: 600; font-size: 15px; margin-bottom: 4px; color: var(--color-text); }
    .timeline-meta { font-size: 13px; color: var(--color-text-muted); display: flex; flex-wrap: wrap; gap: 12px; }
    .timeline-meta span { display: flex; align-items: center; gap: 4px; }
    .timeline-actions { margin-top: 10px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }

    .detour-badge { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; background: #FFF8E8; color: #92400e; border-radius: 4px; font-size: 11px; font-weight: 500; }
    .detour-badge.far { background: #FDE8E8; color: var(--color-secondary); }

    .stop-time-input { display: inline-flex; align-items: center; gap: 6px; background: var(--color-bg-alt); padding: 4px 8px; border-radius: 6px; }
    .stop-time-input input { width: 50px; padding: 4px 6px; border: 1px solid var(--color-border); border-radius: 4px; font-size: 12px; text-align: center; }
    .stop-time-input span { font-size: 12px; color: var(--color-text-muted); }

    .planned-stop-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; background: #F59E0B; color: #78350F; border-radius: 12px; font-size: 11px; font-weight: 600; }
    .possible-stop-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; background: var(--color-primary); color: white; border-radius: 12px; font-size: 11px; font-weight: 600; }

    .selected-stops-summary { background: var(--color-white); border: 1px solid var(--color-border); border-radius: 12px; padding: 16px; margin-top: 12px; }
    .selected-stops-summary h4 { font-size: 13px; font-weight: 600; color: var(--color-text); margin-bottom: 12px; }
    .selected-stop-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: var(--color-bg-alt); border-radius: 8px; margin-bottom: 8px; font-size: 13px; }
    .selected-stop-item:last-child { margin-bottom: 0; }
    .selected-stop-item.planned { background: #FFFBEB; border: 1px solid #F59E0B; }
    .selected-stop-item.possible { background: #E8F0F8; border: 1px solid var(--color-primary); }
    .selected-stop-info { display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0; }
    .selected-stop-name { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
    .selected-stop-meta { color: var(--color-text-muted); font-size: 12px; }
    .selected-stop-remove { background: none; border: none; color: var(--color-text-muted); cursor: pointer; padding: 4px; border-radius: 4px; }
    .selected-stop-remove:hover { background: #FDE8E8; color: var(--color-secondary); }
    .selected-stop-details { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .selected-stop-hours { font-size: 11px; color: var(--color-text-muted); }
    .selected-stop-hours.open { color: var(--color-accent); }
    .selected-stop-hours.closed { color: var(--color-secondary); }
    .stop-time-editor { display: flex; align-items: center; gap: 2px; background: var(--color-bg-alt); border-radius: 6px; padding: 2px; }
    .time-adjust-btn { width: 22px; height: 22px; border: none; background: var(--color-white); border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 14px; color: var(--color-text); display: flex; align-items: center; justify-content: center; }
    .time-adjust-btn:hover { background: var(--color-border); }
    .stop-time-value { font-size: 12px; font-weight: 500; min-width: 32px; text-align: center; }

    .resource-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px; }
    .resource-card { padding: 20px; position: relative; }
    .resource-card.planned-stop { background: #FFFBEB; border: 1px solid #F59E0B; }
    .resource-card.possible-stop { background: #E8F0F8; border: 1px solid var(--color-primary); }

    .stop-buttons { display: flex; gap: 6px; flex-wrap: wrap; }
    .stop-btn { padding: 4px 10px; font-size: 11px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-white); cursor: pointer; transition: all 0.2s; }
    .stop-btn:hover { border-color: var(--color-text-muted); }
    .stop-btn.planned { background: #FFFBEB; border-color: #F59E0B; color: #92400E; }
    .stop-btn.possible { background: #E8F0F8; border-color: var(--color-primary); color: var(--color-primary); }

    .detour-filter { display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: var(--color-bg-alt); border-radius: 8px; margin-top: 12px; }
    .detour-filter label { font-size: 13px; font-weight: 500; color: var(--color-text); white-space: nowrap; }
    .detour-filter select { padding: 6px 10px; border: 1px solid var(--color-border); border-radius: 6px; font-size: 13px; }
    .detour-filter .refresh-btn { padding: 6px 12px; background: var(--color-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; }
    .detour-filter .refresh-btn:hover { background: var(--color-primary-dark); }

    .location-text { font-size: 11px; color: var(--color-text-muted); font-style: italic; }
    .resource-card-header { display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px; }
    .resource-icon { width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0; }
    .resource-icon.water { background: #E8F0F8; }
    .resource-icon.camp { background: #E8F5E8; }
    .resource-icon.food { background: #FFF8E8; }
    .resource-icon.scenic { background: #f3e8ff; }
    .resource-icon.store { background: #ECFEFF; }
    .resource-name { font-weight: 600; font-size: 15px; line-height: 1.3; color: var(--color-text); }
    .resource-type { font-size: 12px; color: var(--color-text-muted); text-transform: capitalize; margin-top: 2px; }
    .resource-details { font-size: 13px; color: var(--color-text-muted); }
    .resource-details p { margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
    .resource-link { color: var(--color-primary); text-decoration: none; font-size: 13px; display: inline-flex; align-items: center; gap: 4px; margin-right: 12px; }
    .resource-link:hover { text-decoration: underline; }
    .resource-link.gmaps { color: var(--color-accent); }

    .stats-bar { display: grid; grid-template-columns: repeat(6, 1fr); gap: 16px; margin-bottom: 32px; }
    @media (max-width: 1000px) { .stats-bar { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 600px) { .stats-bar { grid-template-columns: repeat(2, 1fr); } }
    .stat-card { padding: 20px; text-align: center; }
    .stat-value { font-size: 28px; font-weight: 700; color: var(--color-text); }
    .stat-label { font-size: 12px; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
    .stat-card.highlight { background: #FFFBEB; border: 1px solid #F59E0B; }

    .filter-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 24px; }
    .pill { padding: 8px 16px; border-radius: 20px; border: 1px solid var(--color-border); background: var(--color-white); cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
    .pill.active { background: var(--color-primary); color: white; border-color: var(--color-primary); }
    .pill:hover:not(.active) { border-color: var(--color-text-muted); }
    .pill-count { background: rgba(0,65,124,0.1); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
    .pill.active .pill-count { background: rgba(255,255,255,0.2); }

    .export-panel { position: fixed; bottom: 24px; right: 24px; z-index: 200; }
    .export-dropdown { position: absolute; bottom: 100%; right: 0; margin-bottom: 8px; background: var(--color-white); border-radius: 12px; box-shadow: 0 10px 40px rgba(5,24,41,0.15); padding: 8px; min-width: 220px; display: none; }
    .export-dropdown.open { display: block; }
    .export-option { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: background 0.2s; }
    .export-option:hover { background: var(--color-bg-alt); }
    .export-option-icon { width: 32px; height: 32px; border-radius: 8px; background: var(--color-bg-alt); display: flex; align-items: center; justify-content: center; font-size: 16px; }

    .loading-overlay { position: fixed; inset: 0; background: rgba(255,251,248,0.97); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
    .loading-card { background: white; border-radius: 16px; padding: 40px 48px; box-shadow: 0 4px 24px rgba(0,0,0,0.1); max-width: 480px; width: 90%; }
    .loading-header { display: flex; align-items: center; gap: 16px; margin-bottom: 24px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--color-border); border-top-color: var(--color-primary); border-radius: 50%; animation: spin 1s linear infinite; flex-shrink: 0; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-title { font-size: 18px; font-weight: 600; color: var(--color-text); }
    .loading-subtitle { font-size: 14px; color: var(--color-text-muted); margin-top: 2px; }
    .progress-container { margin-bottom: 24px; }
    .progress-bar-bg { height: 8px; background: var(--color-bg-alt); border-radius: 4px; overflow: hidden; }
    .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--color-primary), var(--color-accent)); border-radius: 4px; transition: width 0.3s ease; }
    .progress-text { display: flex; justify-content: space-between; margin-top: 8px; font-size: 13px; color: var(--color-text-muted); }
    .loading-steps { border-top: 1px solid var(--color-border); padding-top: 16px; }
    .loading-step { display: flex; align-items: flex-start; gap: 12px; padding: 10px 0; color: var(--color-text-muted); font-size: 14px; line-height: 1.4; }
    .loading-step.active { color: var(--color-text); }
    .loading-step.done { color: var(--color-accent); }
    .loading-step-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 14px; }
    .loading-step.active .loading-step-icon { animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .loading-step-content { flex: 1; }
    .loading-step-label { font-weight: 500; }
    .loading-step-detail { font-size: 12px; color: var(--color-text-muted); margin-top: 2px; font-family: ui-monospace, monospace; }

    .empty-state { text-align: center; padding: 80px 40px; }
    .empty-state h3 { font-size: 20px; font-weight: 600; margin-bottom: 8px; color: var(--color-text); }
    .empty-state p { color: var(--color-text-muted); max-width: 400px; margin: 0 auto; }

    .alert { padding: 16px 20px; border-radius: 10px; margin-bottom: 20px; display: flex; align-items: flex-start; gap: 12px; }
    .alert-info { background: #E8F0F8; color: var(--color-primary); }
    .alert-warning { background: #FFF8E8; color: #92400e; }
    .alert-error { background: #FDE8E8; color: var(--color-secondary); }
    .alert-icon { font-size: 18px; flex-shrink: 0; }
    .alert-content { flex: 1; }
    .alert-title { font-weight: 600; margin-bottom: 4px; }
    .alert-text { font-size: 14px; opacity: 0.9; }

    .leaflet-popup-content-wrapper { border-radius: 10px; }
    .leaflet-popup-content { margin: 12px 16px; }
    .popup-title { font-weight: 600; margin-bottom: 4px; color: var(--color-text); }
    .popup-meta { font-size: 12px; color: var(--color-text-muted); margin-bottom: 2px; }
    .popup-links { margin-top: 8px; display: flex; gap: 12px; }
    .popup-link { color: var(--color-primary); font-size: 12px; text-decoration: none; }
    .popup-link:hover { text-decoration: underline; }
    .popup-link.gmaps { color: var(--color-accent); }

    .route-info { background: #E8F5E8; border: 1px solid var(--color-accent); padding: 16px 20px; border-radius: 10px; margin-bottom: 24px; }
    .route-info-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    .route-info-icon { font-size: 24px; }
    .route-info h3 { font-size: 16px; font-weight: 600; color: var(--color-accent); }
    .route-info p { font-size: 14px; color: var(--color-accent); opacity: 0.8; }

    .history-section { margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--color-border); }
    .history-section h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; color: var(--color-text); }
    .history-list { display: grid; gap: 12px; }
    .history-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 18px; background: var(--color-bg-alt); border-radius: 10px; cursor: pointer; transition: all 0.2s; }
    .history-item:hover { background: var(--color-border); }
    .history-item-info { flex: 1; }
    .history-item-name { font-weight: 500; font-size: 14px; margin-bottom: 2px; color: var(--color-text); }
    .history-item-meta { font-size: 12px; color: var(--color-text-muted); }
    .history-item-actions { display: flex; gap: 8px; }
    .history-delete { padding: 6px; border: none; background: transparent; cursor: pointer; color: var(--color-text-muted); border-radius: 4px; }
    .history-delete:hover { background: #FDE8E8; color: var(--color-secondary); }

    .planned-stops-summary { background: #FFFBEB; border: 1px solid #F59E0B; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; }
    .planned-stops-summary-text { font-size: 14px; color: #92400E; }
    .planned-stops-summary-text strong { font-weight: 600; }

    .mile-marker-icon {
      background: var(--color-white);
      border: 2px solid var(--color-text-muted);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: 600;
      color: var(--color-text);
      white-space: nowrap;
    }

    .speed-input-group { display: flex; align-items: center; gap: 8px; }
    .speed-input-group input[type="number"] { width: 70px; height: 44px; padding: 0 10px; border: 1px solid var(--color-border); border-radius: 8px; font-size: 14px; text-align: center; }
    .speed-input-group input[type="number"]:focus { outline: none; border-color: var(--color-primary); }
    .speed-input-group span { font-size: 13px; color: var(--color-text-muted); }

    .route-controls { background: var(--color-bg-alt); border-radius: 10px; padding: 16px; margin-bottom: 24px; display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-end; }
    .route-controls .form-group { margin-bottom: 0; flex: 0 0 auto; }
    .route-controls input[type="date"],
    .route-controls input[type="time"],
    .route-controls input[type="number"],
    .route-controls select { height: 44px; padding: 0 12px; border: 1px solid var(--color-border); border-radius: 8px; font-size: 14px; }
    .route-controls input[type="date"] { width: 140px; }
    .route-controls input[type="time"] { width: 110px; }
    .route-controls select { width: 100px; }
    .route-controls .speed-input-group input[type="number"] { width: 70px; }
    .route-controls .refresh-btn { height: 44px; padding: 0 20px; background: var(--color-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500; display: flex; align-items: center; gap: 6px; }
    .route-controls .refresh-btn:hover { background: var(--color-primary-dark); }

    .condensed-timeline { padding-left: 20px; }
    .condensed-timeline .mile-marker-row { display: flex; align-items: center; gap: 12px; padding: 8px 0; border-bottom: 1px dashed var(--color-border); }
    .condensed-timeline .mile-marker-row .mile-label { font-weight: 600; color: var(--color-text); min-width: 60px; font-size: 13px; }
    .condensed-timeline .mile-marker-row .eta-label { color: var(--color-text-muted); font-size: 12px; min-width: 70px; }
    .condensed-timeline .stops-in-range { display: flex; flex-wrap: wrap; gap: 6px; flex: 1; }
    .condensed-timeline .mini-stop { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; background: var(--color-white); border: 1px solid var(--color-border); border-radius: 12px; font-size: 11px; cursor: pointer; transition: all 0.2s; }
    .condensed-timeline .mini-stop:hover { border-color: var(--color-text-muted); background: var(--color-bg-alt); }
    .condensed-timeline .mini-stop.planned { background: #FFFBEB; border-color: #F59E0B; }
    .condensed-timeline .mini-stop.possible { background: #E8F0F8; border-color: var(--color-primary); }
    .condensed-timeline .mini-stop.expanded { border-color: var(--color-primary); box-shadow: 0 0 0 2px rgba(0, 65, 124, 0.2); }

    .condensed-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; }
    .condensed-grid .mini-card { padding: 10px 12px; background: var(--color-white); border: 1px solid var(--color-border); border-radius: 8px; cursor: pointer; transition: all 0.2s; }
    .condensed-grid .mini-card:hover { border-color: var(--color-text-muted); box-shadow: 0 2px 4px rgba(5,24,41,0.05); }
    .condensed-grid .mini-card.planned { background: #FFFBEB; border-color: #F59E0B; }
    .condensed-grid .mini-card.possible { background: #E8F0F8; border-color: var(--color-primary); }
    .condensed-grid .mini-card.expanded { border-color: var(--color-primary); box-shadow: 0 0 0 2px rgba(0, 65, 124, 0.2); }

    .poi-popover-overlay { position: fixed; inset: 0; background: rgba(5,24,41,0.3); z-index: 1000; display: flex; align-items: center; justify-content: center; }
    .poi-popover { background: var(--color-white); border-radius: 12px; box-shadow: 0 20px 50px rgba(5,24,41,0.2); max-width: 360px; width: 90%; max-height: 80vh; overflow-y: auto; }
    .poi-popover-header { padding: 16px; border-bottom: 1px solid var(--color-border); display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .poi-popover-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px; color: var(--color-text); }
    .poi-popover-close { background: none; border: none; font-size: 20px; color: var(--color-text-muted); cursor: pointer; padding: 4px; line-height: 1; }
    .poi-popover-close:hover { color: var(--color-text); }
    .poi-popover-body { padding: 16px; }
    .poi-popover-meta { display: flex; flex-direction: column; gap: 8px; font-size: 13px; color: var(--color-text-muted); margin-bottom: 16px; }
    .poi-popover-meta-item { display: flex; align-items: center; gap: 8px; }
    .poi-popover-actions { display: flex; gap: 8px; margin-bottom: 12px; }
    .poi-popover-actions button { flex: 1; padding: 10px 16px; border-radius: 8px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .poi-popover-actions .btn-planned { background: #FFFBEB; border: 1px solid #F59E0B; color: #92400E; }
    .poi-popover-actions .btn-planned:hover { background: #FEF3C7; }
    .poi-popover-actions .btn-possible { background: #E8F0F8; border: 1px solid var(--color-primary); color: var(--color-primary); }
    .poi-popover-actions .btn-possible:hover { background: #D8E8F8; }
    .poi-popover-actions .btn-remove { background: #FDE8E8; border: 1px solid var(--color-secondary); color: var(--color-secondary); }
    .poi-popover-actions .btn-remove:hover { background: #F5D8D8; }
    .poi-popover-links { display: flex; gap: 12px; padding-top: 12px; border-top: 1px solid var(--color-border); }
    .poi-popover-links a { font-size: 12px; color: var(--color-primary); text-decoration: none; display: flex; align-items: center; gap: 4px; }
    .poi-popover-links a:hover { text-decoration: underline; }

    .timeline-mile-marker { display: flex; align-items: center; padding: 8px 0 8px 44px; position: relative; }
    .timeline-mile-marker::before { content: ''; position: absolute; left: 23px; top: 0; bottom: 0; width: 2px; background: var(--color-border); }
    .timeline-mile-marker-dot { width: 8px; height: 8px; background: var(--color-border); border-radius: 50%; position: absolute; left: 20px; }
    .timeline-mile-marker-label { font-size: 11px; color: var(--color-text-muted); font-weight: 500; }

    .on-route-badge { font-size: 10px; color: var(--color-accent); background: #E8F5E8; padding: 2px 6px; border-radius: 4px; }
    .condensed-grid .mini-card-header { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
    .condensed-grid .mini-card-name { font-weight: 500; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--color-text); }
    .condensed-grid .mini-card-meta { font-size: 10px; color: var(--color-text-muted); }
    .condensed-grid .mini-card-hours { font-size: 10px; color: var(--color-text-muted); margin-top: 2px; }
    .condensed-grid .mini-card-hours span { color: var(--color-accent); }
    .condensed-grid .mini-card-hours span.closed { color: var(--color-secondary); }

    .hours-badge { font-size: 10px; padding: 2px 6px; border-radius: 4px; font-weight: 500; }
    .hours-badge.open { background: #E8F5E8; color: var(--color-accent); }
    .hours-badge.closed { background: #FDE8E8; color: var(--color-secondary); }
    .hours-badge.unknown { background: var(--color-bg-alt); color: var(--color-text-muted); }
    .hours-display { font-size: 10px; color: var(--color-text-muted); margin-left: 6px; }

    .view-toggle { display: flex; gap: 4px; background: var(--color-bg-alt); padding: 3px; border-radius: 6px; }
    .view-toggle button { padding: 4px 10px; border: none; background: transparent; cursor: pointer; font-size: 12px; color: var(--color-text-muted); border-radius: 4px; }
    .view-toggle button.active { background: var(--color-white); color: var(--color-text); box-shadow: 0 1px 2px rgba(5,24,41,0.1); }

    /* Featured Routes Homepage Styles */
    .homepage { padding: 60px 0; }
    .homepage-hero { text-align: center; margin-bottom: 48px; }
    .homepage-hero h1 { font-size: 36px; font-weight: 700; color: var(--color-primary); margin-bottom: 12px; }
    .homepage-hero p { font-size: 18px; color: var(--color-text-muted); max-width: 600px; margin: 0 auto; }
    .featured-routes { margin-bottom: 48px; }
    .featured-routes h2 { font-size: 24px; font-weight: 600; color: var(--color-text); margin-bottom: 24px; }
    .featured-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 24px; }
    .featured-card { background: var(--color-white); border-radius: 16px; overflow: hidden; box-shadow: 0 4px 12px rgba(5,24,41,0.08); transition: all 0.3s; cursor: pointer; border: 2px solid transparent; }
    .featured-card:hover { transform: translateY(-4px); box-shadow: 0 12px 32px rgba(5,24,41,0.12); border-color: var(--color-primary); }
    .featured-card-image { height: 180px; background-size: cover; background-position: center; position: relative; }
    .featured-card-image::after { content: ''; position: absolute; inset: 0; background: linear-gradient(to bottom, transparent 50%, rgba(5,24,41,0.7)); }
    .featured-card-badge { position: absolute; top: 12px; left: 12px; background: var(--color-secondary); color: white; padding: 4px 12px; border-radius: 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
    .featured-card-content { padding: 20px; }
    .featured-card-title { font-size: 20px; font-weight: 700; color: var(--color-text); margin-bottom: 8px; }
    .featured-card-stats { display: flex; gap: 16px; margin-bottom: 12px; }
    .featured-card-stat { display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--color-text-muted); }
    .featured-card-stat strong { color: var(--color-text); font-weight: 600; }
    .featured-card-desc { font-size: 14px; color: var(--color-text-muted); line-height: 1.5; margin-bottom: 16px; }
    .featured-card-footer { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .featured-card-gpx-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 500; }
    .featured-card-gpx-badge.available { background: #DEF7EC; color: #03543F; }
    .featured-card-gpx-badge.pending { background: #FEF3C7; color: #92400E; }
    .featured-card-btn { display: inline-flex; align-items: center; gap: 8px; background: var(--color-primary); color: white; padding: 10px 20px; border-radius: 8px; font-weight: 500; font-size: 14px; text-decoration: none; transition: background 0.2s; }
    .featured-card-btn:hover { background: var(--color-primary-dark); }
    .upload-section { background: var(--color-bg-alt); border-radius: 16px; padding: 40px; text-align: center; }
    .upload-section h3 { font-size: 20px; font-weight: 600; color: var(--color-text); margin-bottom: 8px; }
    .upload-section p { font-size: 14px; color: var(--color-text-muted); margin-bottom: 24px; }
    .powered-by { margin-top: 48px; text-align: center; padding-top: 24px; border-top: 1px solid var(--color-border); }
    .powered-by span { font-size: 12px; color: var(--color-text-muted); }
    .powered-by a { color: var(--color-primary); font-weight: 500; text-decoration: none; }
    .powered-by a:hover { text-decoration: underline; }

    /* View Plan Floating Button */
    .view-plan-fab { position: fixed; bottom: 24px; right: 24px; z-index: 999; display: flex; align-items: center; gap: 8px; background: var(--color-primary); color: white; padding: 14px 20px; border-radius: 50px; font-weight: 600; font-size: 14px; box-shadow: 0 4px 12px rgba(0,65,124,0.3); cursor: pointer; border: none; transition: all 0.2s ease; opacity: 0; transform: translateY(20px); pointer-events: none; }
    .view-plan-fab.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }
    .view-plan-fab:hover { background: var(--color-primary-dark); box-shadow: 0 6px 16px rgba(0,65,124,0.4); transform: translateY(-2px); }
    .view-plan-fab.visible:hover { transform: translateY(-2px); }
    .view-plan-fab svg { width: 18px; height: 18px; }
    .view-plan-fab .fab-count { background: #F59E0B; color: #78350F; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 700; margin-left: 4px; }
  </style>
</head>
<body>
  <div id="root">
    <div style="display:flex;align-items:center;justify-content:center;min-height:100vh;font-family:system-ui;">
      <div style="text-align:center;">
        <div style="font-size:24px;margin-bottom:16px;">Loading RouteScout...</div>
        <div style="color:#666;">If this takes more than a few seconds, check browser console for errors.</div>
      </div>
    </div>
  </div>

  <script type="text/babel">
    console.log('RouteScout: Script started loading...');
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // Error Boundary for debugging
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }
      componentDidCatch(error, info) {
        console.error('RouteScout Error:', error, info);
      }
      render() {
        if (this.state.hasError) {
          return (
            <div style={{ padding: '40px', textAlign: 'center', fontFamily: 'system-ui' }}>
              <h2 style={{ color: '#dc2626' }}>Something went wrong</h2>
              <p style={{ color: '#666' }}>{this.state.error?.message || 'Unknown error'}</p>
              <pre style={{ textAlign: 'left', background: '#f3f4f6', padding: '16px', borderRadius: '8px', overflow: 'auto', maxWidth: '600px', margin: '20px auto' }}>
                {this.state.error?.stack}
              </pre>
              <button onClick={() => window.location.reload()} style={{ padding: '12px 24px', background: '#2563eb', color: 'white', border: 'none', borderRadius: '8px', cursor: 'pointer' }}>
                Reload Page
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    // Constants
    const MAX_PLANNED_STOPS = 25;
    const HISTORY_KEY = 'routescout_history';
    const MAX_HISTORY_ITEMS = 10;
    const UNITS_KEY = 'routescout_units';
    const GOOGLE_HOURS_CACHE_KEY = 'routescout_google_hours_cache';
    const GOOGLE_HOURS_CACHE_DAYS = 7;

    // Google Places API Configuration
    // To enable enhanced business hours, add your Google Places API key here
    // Get a key at: https://console.cloud.google.com/apis/credentials
    // Enable "Places API (New)" in your Google Cloud Console
    const GOOGLE_PLACES_API_KEY = 'AIzaSyDeeOZV6ckz-RQXGZTB7nMyaQpdmh6fZQ0'; // Add your API key here

    // Categories that benefit most from Google hours lookup (stores and food)
    const GOOGLE_HOURS_CATEGORIES = ['store', 'food'];

    // Google Places hours cache (localStorage with expiration)
    const getGoogleHoursCache = () => {
      try {
        const cached = localStorage.getItem(GOOGLE_HOURS_CACHE_KEY);
        if (!cached) return {};
        const data = JSON.parse(cached);
        const now = Date.now();
        // Clean expired entries
        const valid = {};
        Object.entries(data).forEach(([key, entry]) => {
          if (entry.expires > now) {
            valid[key] = entry;
          }
        });
        return valid;
      } catch { return {}; }
    };

    const setGoogleHoursCache = (key, hours) => {
      try {
        const cache = getGoogleHoursCache();
        cache[key] = {
          hours,
          expires: Date.now() + (GOOGLE_HOURS_CACHE_DAYS * 24 * 60 * 60 * 1000)
        };
        localStorage.setItem(GOOGLE_HOURS_CACHE_KEY, JSON.stringify(cache));
      } catch {}
    };

    // Fetch business hours from Google Places API
    const fetchGooglePlacesHours = async (poi) => {
      if (!GOOGLE_PLACES_API_KEY) return null;

      // Check cache first
      const cacheKey = `${poi.name}-${poi.coordinates[0].toFixed(4)}-${poi.coordinates[1].toFixed(4)}`;
      const cache = getGoogleHoursCache();
      if (cache[cacheKey]) {
        console.log(`Google hours cache hit: ${poi.name}`);
        return cache[cacheKey].hours;
      }

      try {
        // Step 1: Find the place using Text Search
        const searchUrl = `https://places.googleapis.com/v1/places:searchText`;
        const searchBody = {
          textQuery: poi.name,
          locationBias: {
            circle: {
              center: {
                latitude: poi.coordinates[0],
                longitude: poi.coordinates[1]
              },
              radius: 500.0
            }
          },
          maxResultCount: 1
        };

        const searchResponse = await fetch(searchUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': GOOGLE_PLACES_API_KEY,
            'X-Goog-FieldMask': 'places.id,places.displayName,places.regularOpeningHours'
          },
          body: JSON.stringify(searchBody)
        });

        if (!searchResponse.ok) {
          console.log(`Google Places search failed for ${poi.name}: ${searchResponse.status}`);
          return null;
        }

        const searchData = await searchResponse.json();
        const place = searchData.places?.[0];

        if (!place) {
          console.log(`No Google Place found for: ${poi.name}`);
          setGoogleHoursCache(cacheKey, null); // Cache the miss
          return null;
        }

        // Extract opening hours
        const hours = place.regularOpeningHours;
        if (hours) {
          // Convert Google format to OSM-like format for consistency
          const weekdayText = hours.weekdayDescriptions?.join('; ') || null;
          console.log(`Google hours found for ${poi.name}: ${weekdayText}`);
          setGoogleHoursCache(cacheKey, weekdayText);
          return weekdayText;
        }

        setGoogleHoursCache(cacheKey, null);
        return null;
      } catch (err) {
        console.log(`Google Places API error for ${poi.name}:`, err.message);
        return null;
      }
    };

    // Batch enhance POIs with Google Places hours
    const enhancePOIsWithGoogleHours = async (pois, onProgress) => {
      if (!GOOGLE_PLACES_API_KEY) {
        console.log('Google Places API key not configured - skipping hours enhancement');
        return pois;
      }

      // Only enhance POIs that:
      // 1. Don't already have OSM hours
      // 2. Are in priority categories (stores, food)
      const poisNeedingHours = pois.filter(poi =>
        !poi.openingHours &&
        GOOGLE_HOURS_CATEGORIES.includes(poi.category)
      );

      if (poisNeedingHours.length === 0) {
        console.log('No POIs need Google hours enhancement');
        return pois;
      }

      // Limit to avoid excessive API costs (max 30 lookups per route)
      const toEnhance = poisNeedingHours.slice(0, 30);
      console.log(`Enhancing ${toEnhance.length} POIs with Google Places hours`);
      onProgress?.(`Fetching business hours for ${toEnhance.length} locations...`);

      // Process in batches of 5 with delay to respect rate limits
      const batchSize = 5;
      for (let i = 0; i < toEnhance.length; i += batchSize) {
        const batch = toEnhance.slice(i, i + batchSize);
        await Promise.all(batch.map(async (poi) => {
          const hours = await fetchGooglePlacesHours(poi);
          if (hours) {
            poi.openingHours = hours;
            poi.hoursSource = 'google';
          }
        }));
        // Small delay between batches
        if (i + batchSize < toEnhance.length) {
          await new Promise(r => setTimeout(r, 200));
        }
      }

      const enhanced = pois.filter(p => p.hoursSource === 'google').length;
      console.log(`Enhanced ${enhanced} POIs with Google hours`);

      return pois;
    };

    // Icons
    const Icons = {
      Bike: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <circle cx="5" cy="17" r="3"/><circle cx="19" cy="17" r="3"/>
          <path d="M12 17V5l4 4M8 8h4"/>
        </svg>
      ),
      Upload: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="20" height="20">
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
        </svg>
      ),
      Link: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="20" height="20">
          <path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/>
          <path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/>
        </svg>
      ),
      History: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="20" height="20">
          <circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/>
        </svg>
      ),
      Download: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="20" height="20">
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
        </svg>
      ),
      Trash: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="16" height="16">
          <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
        </svg>
      ),
      ExternalLink: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="14" height="14">
          <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6M15 3h6v6M10 14L21 3"/>
        </svg>
      ),
      Mountain: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="16" height="16">
          <path d="M8 3l4 8 5-5 5 15H2L8 3z"/>
        </svg>
      ),
      Route: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="16" height="16">
          <circle cx="6" cy="19" r="3"/><path d="M9 19h8.5a3.5 3.5 0 000-7h-11a3.5 3.5 0 010-7H15"/><circle cx="18" cy="5" r="3"/>
        </svg>
      ),
      MapPin: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="16" height="16">
          <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/>
        </svg>
      ),
      ChevronRight: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="16" height="16">
          <polyline points="9 18 15 12 9 6"/>
        </svg>
      ),
      Check: () => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" width="14" height="14">
          <polyline points="20 6 9 17 4 12"/>
        </svg>
      ),
      Water: () => <span>üíß</span>,
      Camp: () => <span>‚õ∫</span>,
      Food: () => <span>üç¥</span>,
      Scenic: () => <span>üì∏</span>,
      Store: () => <span>üè™</span>,
    };

    // POI Categories with OSM tags (excluding picnic_site from camp)
    // Note: Fuel/gas stations merged into Convenience category since this is a cycling app
    const POI_CATEGORIES = {
      water: {
        label: 'Water',
        icon: Icons.Water,
        color: '#00417C', // Mishigami Deep Blue
        bgColor: '#E8F0F8',
        osmTags: [
          'amenity=drinking_water',
          'amenity=water_point',
          'natural=spring',
          'man_made=water_tap'
        ]
      },
      camp: {
        label: 'Camping',
        icon: Icons.Camp,
        color: '#277521', // Mishigami Green
        bgColor: '#E8F5E8',
        osmTags: [
          'tourism=camp_site',
          'tourism=caravan_site',
          'tourism=wilderness_hut'
        ],
        excludeTags: ['shelter_type=picnic_shelter', 'tourism=picnic_site']
      },
      food: {
        label: 'Food',
        icon: Icons.Food,
        color: '#d97706',
        bgColor: '#FFF8E8',
        osmTags: [
          'amenity=restaurant',
          'amenity=cafe',
          'amenity=fast_food',
          'amenity=pub',
          'amenity=bar'
        ]
      },
      store: {
        label: 'Convenience',
        icon: Icons.Store,
        color: '#0891B2', // Cyan
        bgColor: '#ECFEFF',
        osmTags: [
          'shop=supermarket',
          'shop=convenience',
          'shop=general',
          'shop=grocery',
          'amenity=fuel'
        ]
      },
      scenic: {
        label: 'Scenic',
        icon: Icons.Scenic,
        color: '#9333ea',
        bgColor: '#f3e8ff',
        osmTags: [
          'tourism=viewpoint',
          'tourism=attraction',
          'natural=peak',
          'natural=waterfall',
          'historic=monument'
        ]
      }
    };

    // Unit conversion helpers
    const kmToMi = (km) => km * 0.621371;
    const miToKm = (mi) => mi / 0.621371;
    const mToFt = (m) => m * 3.28084;
    const ftToM = (ft) => ft / 3.28084;

    // History management
    const getHistory = () => {
      try {
        const data = localStorage.getItem(HISTORY_KEY);
        return data ? JSON.parse(data) : [];
      } catch {
        return [];
      }
    };

    const saveToHistory = (route, pois) => {
      try {
        const history = getHistory();
        const entry = {
          id: Date.now(),
          name: route.name,
          distance: route.distance,
          elevation: route.elevation,
          poiCount: pois.length,
          date: new Date().toISOString(),
          routeData: route,
          poisData: pois.map(p => ({
            ...p,
            eta: null
          }))
        };

        const filtered = history.filter(h => h.name !== route.name);
        const updated = [entry, ...filtered].slice(0, MAX_HISTORY_ITEMS);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(updated));
        return updated;
      } catch (e) {
        console.error('Failed to save history:', e);
        return getHistory();
      }
    };

    const deleteFromHistory = (id) => {
      try {
        const history = getHistory();
        const updated = history.filter(h => h.id !== id);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(updated));
        return updated;
      } catch {
        return getHistory();
      }
    };

    // GPX Parser - optimized for large files
    const parseGPX = (gpxText) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(gpxText, 'text/xml');

      const nameEl = doc.querySelector('name');
      const name = nameEl ? nameEl.textContent : 'Unnamed Route';

      const trkpts = doc.querySelectorAll('trkpt');
      const rtepts = doc.querySelectorAll('rtept');
      const points = trkpts.length > 0 ? trkpts : rtepts;
      const totalPoints = points.length;

      // For very large files, we'll downsample to ~2000 points max for performance
      // while keeping all points for accurate distance/elevation calculation
      const MAX_DISPLAY_POINTS = 2000;
      const sampleRate = totalPoints > MAX_DISPLAY_POINTS ? Math.ceil(totalPoints / MAX_DISPLAY_POINTS) : 1;

      const allCoordinates = []; // Full resolution for distance calc
      const displayCoordinates = []; // Downsampled for rendering
      let totalElevationGain = 0;
      let prevEle = null;
      let prevLat = null;
      let prevLon = null;
      let cumulativeDistance = 0;

      // Pre-calculate constants
      const DEG_TO_RAD = Math.PI / 180;
      const R = 6371; // km

      for (let idx = 0; idx < totalPoints; idx++) {
        const pt = points[idx];
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        const eleEl = pt.querySelector('ele');
        const ele = eleEl ? parseFloat(eleEl.textContent) : null;

        if (isNaN(lat) || isNaN(lon)) continue;

        // Calculate cumulative distance
        if (prevLat !== null) {
          const dLat = (lat - prevLat) * DEG_TO_RAD;
          const dLon = (lon - prevLon) * DEG_TO_RAD;
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(prevLat * DEG_TO_RAD) * Math.cos(lat * DEG_TO_RAD) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          cumulativeDistance += R * c;
        }

        // Track elevation gain
        if (ele !== null && prevEle !== null && ele > prevEle) {
          totalElevationGain += (ele - prevEle);
        }

        // Store for display (downsampled) - always include first and last
        if (idx % sampleRate === 0 || idx === totalPoints - 1) {
          displayCoordinates.push([lat, lon, ele, cumulativeDistance]);
        }

        prevLat = lat;
        prevLon = lon;
        prevEle = ele;
      }

      console.log(`GPX parsed: ${totalPoints} points -> ${displayCoordinates.length} display points`);

      return {
        name,
        coordinates: displayCoordinates,
        distance: cumulativeDistance,
        elevation: totalElevationGain,
        totalPoints
      };
    };

    // Calculate distance between two points in meters
    const haversineDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    };

    // Find minimum distance from POI to route - optimized with spatial indexing
    const findDistanceOffRoute = (poiLat, poiLon, routeCoords, spatialIndex = null) => {
      // If we have a spatial index, use it for faster lookup
      if (spatialIndex) {
        const gridKey = `${Math.floor(poiLat * 10)},${Math.floor(poiLon * 10)}`;
        const nearbyIndices = spatialIndex[gridKey] || [];

        // Also check adjacent cells
        const adjacentKeys = [
          `${Math.floor(poiLat * 10) - 1},${Math.floor(poiLon * 10)}`,
          `${Math.floor(poiLat * 10) + 1},${Math.floor(poiLon * 10)}`,
          `${Math.floor(poiLat * 10)},${Math.floor(poiLon * 10) - 1}`,
          `${Math.floor(poiLat * 10)},${Math.floor(poiLon * 10) + 1}`,
        ];

        const indicesToCheck = [...nearbyIndices];
        adjacentKeys.forEach(key => {
          if (spatialIndex[key]) indicesToCheck.push(...spatialIndex[key]);
        });

        if (indicesToCheck.length > 0) {
          let minDist = Infinity;
          let closestIdx = 0;

          indicesToCheck.forEach(idx => {
            const [lat, lon] = routeCoords[idx];
            const dist = haversineDistance(poiLat, poiLon, lat, lon);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          });

          return { distanceMeters: minDist, closestIdx };
        }
      }

      // Fallback: sample route points for performance (every 10th point for large routes)
      const sampleRate = routeCoords.length > 500 ? Math.ceil(routeCoords.length / 200) : 1;

      let minDist = Infinity;
      let closestIdx = 0;

      for (let idx = 0; idx < routeCoords.length; idx += sampleRate) {
        const [lat, lon] = routeCoords[idx];
        const dist = haversineDistance(poiLat, poiLon, lat, lon);
        if (dist < minDist) {
          minDist = dist;
          closestIdx = idx;
        }
      }

      // Refine search around the closest point
      const searchStart = Math.max(0, closestIdx - sampleRate);
      const searchEnd = Math.min(routeCoords.length - 1, closestIdx + sampleRate);

      for (let idx = searchStart; idx <= searchEnd; idx++) {
        const [lat, lon] = routeCoords[idx];
        const dist = haversineDistance(poiLat, poiLon, lat, lon);
        if (dist < minDist) {
          minDist = dist;
          closestIdx = idx;
        }
      }

      return { distanceMeters: minDist, closestIdx };
    };

    // Build spatial index for route coordinates
    const buildSpatialIndex = (routeCoords) => {
      const index = {};
      routeCoords.forEach(([lat, lon], idx) => {
        const key = `${Math.floor(lat * 10)},${Math.floor(lon * 10)}`;
        if (!index[key]) index[key] = [];
        index[key].push(idx);
      });
      return index;
    };

    // Overpass API Query Builder - optimized for long routes
    const buildOverpassQuery = (coordinates, categories, radius = 1500) => {
      // For long routes, we need to sample intelligently
      // Use cumulative distance from coordinates (4th element) if available
      const totalDist = coordinates[coordinates.length - 1]?.[3] || 0;

      // Sample every ~5km along the route, max 60 points for good coverage
      // Increased radius to 1500m to catch POIs in nearby towns
      const targetSampleKm = 5;
      const maxSamplePoints = 60;

      let samplePoints = [];

      if (totalDist > 0) {
        // Use distance-based sampling
        const sampleInterval = Math.max(targetSampleKm, totalDist / maxSamplePoints);
        let nextSampleDist = 0;

        for (let i = 0; i < coordinates.length; i++) {
          const dist = coordinates[i][3] || 0;
          if (dist >= nextSampleDist || i === 0) {
            samplePoints.push(coordinates[i]);
            nextSampleDist = dist + sampleInterval;
          }
        }

        // Always include last point
        if (samplePoints[samplePoints.length - 1] !== coordinates[coordinates.length - 1]) {
          samplePoints.push(coordinates[coordinates.length - 1]);
        }
      } else {
        // Fallback: uniform sampling by index
        const step = Math.max(1, Math.floor(coordinates.length / maxSamplePoints));
        samplePoints = coordinates.filter((_, i) => i % step === 0 || i === coordinates.length - 1);
      }

      // Limit to max points
      if (samplePoints.length > maxSamplePoints) {
        const step = Math.ceil(samplePoints.length / maxSamplePoints);
        samplePoints = samplePoints.filter((_, i) => i % step === 0 || i === samplePoints.length - 1);
      }

      const coordStr = samplePoints.map(([lat, lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join(',');

      console.log(`Overpass query: ${samplePoints.length} sample points for ${totalDist.toFixed(1)}km route (radius: 1500m, interval: ~${(totalDist / samplePoints.length).toFixed(1)}km)`);

      // Log sample point distribution for debugging
      if (samplePoints.length > 0) {
        const firstPt = samplePoints[0];
        const lastPt = samplePoints[samplePoints.length - 1];
        console.log(`Sample coverage: (${firstPt[0].toFixed(3)}, ${firstPt[1].toFixed(3)}) to (${lastPt[0].toFixed(3)}, ${lastPt[1].toFixed(3)})`);
      }

      const tagQueries = [];
      Object.entries(categories).forEach(([cat, config]) => {
        config.osmTags.forEach(tag => {
          const [key, value] = tag.split('=');
          tagQueries.push(`node["${key}"="${value}"](around:${radius},${coordStr});`);
          tagQueries.push(`way["${key}"="${value}"](around:${radius},${coordStr});`);
        });
      });

      return `[out:json][timeout:90];(${tagQueries.join('')});out center;`;
    };

    // Calculate route segments for batch processing long routes
    const calculateRouteSegments = (coordinates) => {
      const totalDist = coordinates[coordinates.length - 1]?.[3] || 0; // km

      // Determine segment count based on route length
      // ~80km per segment is a sweet spot for Overpass complexity
      const segmentSizeKm = 80;
      const minSegments = 1;
      const maxSegments = 8;

      let targetSegments = Math.ceil(totalDist / segmentSizeKm);
      targetSegments = Math.min(Math.max(targetSegments, minSegments), maxSegments);

      // For short routes (<100km), use single segment
      if (totalDist < 100) {
        return [{ coordinates, startDist: 0, endDist: totalDist }];
      }

      const segments = [];
      const segmentDistKm = totalDist / targetSegments;

      let segmentStart = 0;
      let currentSegment = [];
      let segmentIndex = 0;

      for (let i = 0; i < coordinates.length; i++) {
        const dist = coordinates[i][3] || 0;
        const segmentEnd = (segmentIndex + 1) * segmentDistKm;

        currentSegment.push(coordinates[i]);

        // Check if we've crossed into next segment or reached end
        if (dist >= segmentEnd || i === coordinates.length - 1) {
          if (currentSegment.length > 0) {
            segments.push({
              coordinates: currentSegment,
              startDist: segmentStart,
              endDist: dist
            });
            segmentStart = dist;
            segmentIndex++;
            currentSegment = [coordinates[i]]; // Overlap last point for continuity
          }
        }
      }

      console.log(`Route segmented: ${totalDist.toFixed(0)}km into ${segments.length} segments`);
      segments.forEach((seg, i) => {
        console.log(`  Segment ${i + 1}: ${seg.startDist.toFixed(0)}-${seg.endDist.toFixed(0)}km (${seg.coordinates.length} points)`);
      });

      return segments;
    };

    // Fetch POIs for a single route segment
    const fetchPOIsForSegment = async (segmentCoords, categories, segmentIndex, totalSegments, retryCount = 0) => {
      const query = buildOverpassQuery(segmentCoords, categories);

      // Use different endpoints to distribute load
      const endpoints = [
        'https://overpass-api.de/api/interpreter',
        'https://overpass.kumi.systems/api/interpreter',
        'https://maps.mail.ru/osm/tools/overpass/api/interpreter'
      ];
      const endpoint = endpoints[(segmentIndex + retryCount) % endpoints.length];

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000); // 1 minute per segment

      try {
        console.log(`Segment ${segmentIndex}/${totalSegments}: Querying ${endpoint}...`);

        const response = await fetch(endpoint, {
          method: 'POST',
          body: query,
          headers: { 'Content-Type': 'text/plain' },
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          if ((response.status === 429 || response.status === 504) && retryCount < 2) {
            console.log(`Segment ${segmentIndex}: Server returned ${response.status}, retrying...`);
            await new Promise(r => setTimeout(r, 2000 * (retryCount + 1)));
            return fetchPOIsForSegment(segmentCoords, categories, segmentIndex, totalSegments, retryCount + 1);
          }
          throw new Error(`Segment ${segmentIndex} failed: ${response.status}`);
        }

        const data = await response.json();
        console.log(`Segment ${segmentIndex}: Got ${data.elements?.length || 0} raw elements`);
        return data.elements || [];

      } catch (err) {
        clearTimeout(timeoutId);

        if (err.name === 'AbortError') {
          console.error(`Segment ${segmentIndex}: Timed out`);
          if (retryCount < 1) {
            return fetchPOIsForSegment(segmentCoords, categories, segmentIndex, totalSegments, retryCount + 1);
          }
        }

        // Don't throw - return empty array so other segments can still succeed
        console.error(`Segment ${segmentIndex} failed:`, err.message);
        return [];
      }
    };

    // Fetch POIs from Overpass API with batch processing for long routes
    const fetchPOIs = async (coordinates, onProgress, categoriesToSearch = null) => {
      // Filter categories to only those requested
      const categories = categoriesToSearch
        ? Object.fromEntries(Object.entries(POI_CATEGORIES).filter(([key]) => categoriesToSearch.includes(key)))
        : POI_CATEGORIES;

      // Calculate segments for batch processing
      const segments = calculateRouteSegments(coordinates);
      const totalDist = coordinates[coordinates.length - 1]?.[3] || 0;

      let allElements = [];

      if (segments.length === 1) {
        // Short route - single query (original behavior)
        onProgress?.('Querying OpenStreetMap...');
        const query = buildOverpassQuery(coordinates, categories);
        console.log('Overpass query length:', query.length, 'chars');

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000);

        try {
          const endpoints = [
            'https://overpass-api.de/api/interpreter',
            'https://overpass.kumi.systems/api/interpreter',
            'https://maps.mail.ru/osm/tools/overpass/api/interpreter'
          ];

          let response;
          let lastError;

          for (let attempt = 0; attempt < 3; attempt++) {
            try {
              const endpoint = endpoints[attempt % endpoints.length];
              console.log(`Attempt ${attempt + 1}: Fetching from ${endpoint}...`);

              response = await fetch(endpoint, {
                method: 'POST',
                body: query,
                headers: { 'Content-Type': 'text/plain' },
                signal: controller.signal
              });

              if (response.ok) break;

              if (response.status === 429 || response.status === 504) {
                console.log(`Server returned ${response.status}, trying next endpoint...`);
                await new Promise(r => setTimeout(r, 2000));
                continue;
              }

              throw new Error(`HTTP ${response.status}`);
            } catch (err) {
              lastError = err;
              if (err.name === 'AbortError') throw err;
              if (attempt < 2) {
                await new Promise(r => setTimeout(r, 1000));
              }
            }
          }

          clearTimeout(timeoutId);

          if (!response?.ok) {
            throw lastError || new Error('All endpoints failed');
          }

          const data = await response.json();
          allElements = data.elements || [];
          console.log(`Overpass returned ${allElements.length} raw elements`);

        } catch (err) {
          clearTimeout(timeoutId);
          if (err.name === 'AbortError') {
            throw new Error('OpenStreetMap query timed out. Try again later.');
          }
          throw new Error('OpenStreetMap servers are busy. Please wait a minute and try again.');
        }

      } else {
        // Long route - batch processing with parallel segment queries
        onProgress?.(`Processing ${segments.length} route segments (${totalDist.toFixed(0)}km route)...`);
        console.log(`Batch processing: ${segments.length} segments for ${totalDist.toFixed(0)}km route`);

        // Query all segments in parallel
        const segmentPromises = segments.map((segment, idx) => {
          return fetchPOIsForSegment(segment.coordinates, categories, idx + 1, segments.length)
            .then(elements => {
              onProgress?.(`Segment ${idx + 1}/${segments.length} complete (${elements.length} found)`);
              return elements;
            });
        });

        const segmentResults = await Promise.all(segmentPromises);

        // Merge all elements from all segments
        allElements = segmentResults.flat();
        console.log(`Batch query complete: ${allElements.length} total raw elements from ${segments.length} segments`);

        // Count successful segments
        const successfulSegments = segmentResults.filter(r => r.length > 0).length;
        if (successfulSegments < segments.length) {
          console.warn(`${segments.length - successfulSegments} segment(s) returned no results`);
        }
      }

      onProgress?.('Processing POI data...');

      // Build spatial index for faster lookups
      const spatialIndex = buildSpatialIndex(coordinates);

      const pois = [];

      allElements.forEach(el => {
        const lat = el.lat || el.center?.lat;
        const lon = el.lon || el.center?.lon;
        if (!lat || !lon) return;

        const tags = el.tags || {};

        const isPicnicShelter = tags.shelter_type === 'picnic_shelter' ||
                                tags.tourism === 'picnic_site' ||
                                (tags.amenity === 'shelter' && tags.shelter_type !== 'basic_hut');

        let category = null;
        let type = '';

        for (const [cat, config] of Object.entries(POI_CATEGORIES)) {
          if (cat === 'camp' && isPicnicShelter) continue;

          for (const osmTag of config.osmTags) {
            const [key, value] = osmTag.split('=');
            if (tags[key] === value) {
              category = cat;
              type = value.replace(/_/g, ' ');
              break;
            }
          }
          if (category) break;
        }

        if (!category) return;

        const name = tags.name || tags['name:en'] || `Unnamed ${type}`;

        // Try to get location from OSM address tags
        const city = tags['addr:city'] || tags['addr:town'] || tags['addr:village'] || '';
        const state = tags['addr:state'] || '';
        const location = city && state ? `${city}, ${state}` : (city || state || null);

        const { distanceMeters, closestIdx } = findDistanceOffRoute(lat, lon, coordinates, spatialIndex);
        const progressRatio = closestIdx / (coordinates.length - 1);

        // Extract opening hours from OSM tags
        const openingHours = tags.opening_hours || tags['opening_hours:covid19'] || null;

        pois.push({
          id: el.id,
          name,
          type,
          category,
          coordinates: [lat, lon],
          progressRatio,
          distanceOffRoute: Math.round(distanceMeters),
          location,
          openingHours,
          tags,
          osmId: el.id,
          osmType: el.type
        });
      });

      console.log(`Found ${pois.length} POIs before deduplication`);

      const seen = new Set();
      const dedupedPois = pois.filter(poi => {
        const key = `${poi.name}-${poi.coordinates[0].toFixed(4)}-${poi.coordinates[1].toFixed(4)}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });

      // Fetch locations for POIs that don't have location from OSM tags
      // Limit to avoid rate limiting - batch geocode only POIs without location
      const poisWithoutLocation = dedupedPois.filter(p => !p.location);
      if (poisWithoutLocation.length > 0) {
        onProgress?.(`Getting location info for ${Math.min(poisWithoutLocation.length, 20)} resources...`);

        // Only geocode up to 20 POIs to avoid rate limiting
        const toGeocode = poisWithoutLocation.slice(0, 20);
        await Promise.all(
          toGeocode.map(async (poi, idx) => {
            // Stagger requests to avoid rate limiting
            await new Promise(r => setTimeout(r, idx * 200));
            const loc = await reverseGeocode(poi.coordinates[0], poi.coordinates[1]);
            if (loc) poi.location = loc;
          })
        );
      }

      // Enhance POIs with Google Places hours (for stores/food without OSM hours)
      const enhancedPois = await enhancePOIsWithGoogleHours(dedupedPois, onProgress);

      return enhancedPois;
    };

    // Calculate POI details with planned stops and possible stops
    const enrichPOIs = (pois, routeDistance, startTime, avgSpeed, plannedStops = {}, possibleStops = {}) => {
      const sorted = [...pois].sort((a, b) => a.progressRatio - b.progressRatio);
      let accumulatedStopTime = 0;

      return sorted.map(poi => {
        const distanceKm = poi.progressRatio * routeDistance;
        const ridingHours = distanceKm / avgSpeed;
        const totalHours = ridingHours + (accumulatedStopTime / 60);
        const eta = new Date(startTime.getTime() + totalHours * 60 * 60 * 1000);
        const stopMinutes = plannedStops[poi.id] || 0;
        const isPossibleStop = possibleStops[poi.id] === true;

        if (stopMinutes > 0) {
          accumulatedStopTime += stopMinutes;
        }

        // Parse opening hours relative to ETA
        const hoursInfo = parseOpeningHours(poi.openingHours, eta);

        return {
          ...poi,
          distanceKm,
          hoursFromStart: totalHours,
          eta,
          isPlannedStop: stopMinutes > 0,
          isPossibleStop,
          isSelected: stopMinutes > 0 || isPossibleStop, // Either type of selection
          stopMinutes,
          hoursInfo // { raw, isOpen, display }
        };
      });
    };

    // Reverse geocode to get town/state (using Nominatim)
    const reverseGeocode = async (lat, lon) => {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&zoom=10`,
          { headers: { 'User-Agent': 'RouteScout/1.0' } }
        );
        if (!response.ok) return null;
        const data = await response.json();
        const address = data.address || {};
        const city = address.city || address.town || address.village || address.hamlet || '';
        const state = address.state || '';
        return city && state ? `${city}, ${state}` : (city || state || null);
      } catch {
        return null;
      }
    };

    // Format helpers
    const formatTime = (date) => date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    const formatDate = (date) => date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

    // Parse OSM or Google opening_hours and check if open at given time
    const parseOpeningHours = (hoursString, checkTime = new Date()) => {
      if (!hoursString) return { raw: null, isOpen: null, display: null };

      // Handle common simple formats
      if (hoursString === '24/7' || hoursString.toLowerCase().includes('open 24 hours')) {
        return { raw: hoursString, isOpen: true, display: '24/7' };
      }

      // Days of week mapping (OSM format)
      const dayMapOSM = { 'Mo': 1, 'Tu': 2, 'We': 3, 'Th': 4, 'Fr': 5, 'Sa': 6, 'Su': 0 };
      // Days of week mapping (Google format)
      const dayMapGoogle = {
        'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4,
        'friday': 5, 'saturday': 6, 'sunday': 0
      };
      const dayOfWeek = checkTime.getDay();
      const currentTime = checkTime.getHours() * 60 + checkTime.getMinutes();

      try {
        // Check if this looks like Google format (contains full day names with colons)
        const isGoogleFormat = /monday|tuesday|wednesday|thursday|friday|saturday|sunday/i.test(hoursString);

        if (isGoogleFormat) {
          // Parse Google format: "Monday: 9:00 AM ‚Äì 5:00 PM; Tuesday: 9:00 AM ‚Äì 5:00 PM"
          const rules = hoursString.split(';').map(r => r.trim());
          let isOpen = null;
          let todayHours = null;

          for (const rule of rules) {
            // Match "Monday: 9:00 AM ‚Äì 5:00 PM" or "Monday: Closed"
            const match = rule.match(/^(\w+):\s*(.+)$/i);
            if (!match) continue;

            const [, dayName, hoursText] = match;
            const dayIdx = dayMapGoogle[dayName.toLowerCase()];

            if (dayIdx === dayOfWeek) {
              if (hoursText.toLowerCase() === 'closed') {
                todayHours = 'Closed';
                isOpen = false;
              } else {
                // Parse time range like "9:00 AM ‚Äì 5:00 PM" or "9:00 AM - 5:00 PM"
                const timeMatch = hoursText.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?\s*[‚Äì-]\s*(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
                if (timeMatch) {
                  let [, startH, startM, startPeriod, endH, endM, endPeriod] = timeMatch;
                  startH = parseInt(startH);
                  startM = parseInt(startM);
                  endH = parseInt(endH);
                  endM = parseInt(endM);

                  // Convert to 24-hour
                  if (startPeriod?.toUpperCase() === 'PM' && startH !== 12) startH += 12;
                  if (startPeriod?.toUpperCase() === 'AM' && startH === 12) startH = 0;
                  if (endPeriod?.toUpperCase() === 'PM' && endH !== 12) endH += 12;
                  if (endPeriod?.toUpperCase() === 'AM' && endH === 12) endH = 0;

                  const startMins = startH * 60 + startM;
                  const endMins = endH * 60 + endM;

                  todayHours = hoursText.trim();
                  isOpen = currentTime >= startMins && currentTime < endMins;
                } else {
                  todayHours = hoursText.trim();
                }
              }
              break;
            }
          }

          return {
            raw: hoursString,
            isOpen,
            display: todayHours || hoursString.substring(0, 30) + (hoursString.length > 30 ? '...' : '')
          };
        }

        // OSM format parsing
        const rules = hoursString.split(';').map(r => r.trim());
        let isOpen = null;
        let todayHours = null;

        for (const rule of rules) {
          // Match patterns like "Mo-Fr 08:00-18:00" or "Sa 09:00-14:00"
          const match = rule.match(/^([A-Za-z,-]+)\s+(\d{1,2}:\d{2})-(\d{1,2}:\d{2})$/);
          if (!match) continue;

          const [, days, startStr, endStr] = match;

          // Parse days range
          let appliesToday = false;
          if (days.includes('-')) {
            const [startDay, endDay] = days.split('-');
            const startIdx = dayMapOSM[startDay];
            const endIdx = dayMapOSM[endDay];
            if (startIdx !== undefined && endIdx !== undefined) {
              if (startIdx <= endIdx) {
                appliesToday = dayOfWeek >= startIdx && dayOfWeek <= endIdx;
              } else {
                // Wraps around (e.g., Fr-Mo)
                appliesToday = dayOfWeek >= startIdx || dayOfWeek <= endIdx;
              }
            }
          } else {
            // Single days or comma-separated
            const dayList = days.split(',');
            appliesToday = dayList.some(d => dayMapOSM[d.trim()] === dayOfWeek);
          }

          if (appliesToday) {
            const [startH, startM] = startStr.split(':').map(Number);
            const [endH, endM] = endStr.split(':').map(Number);
            const startMins = startH * 60 + startM;
            const endMins = endH * 60 + endM;

            todayHours = `${startStr}-${endStr}`;
            isOpen = currentTime >= startMins && currentTime < endMins;
            break;
          }
        }

        return {
          raw: hoursString,
          isOpen,
          display: todayHours || hoursString.substring(0, 30) + (hoursString.length > 30 ? '...' : '')
        };
      } catch (e) {
        // If parsing fails, just show the raw string
        return { raw: hoursString, isOpen: null, display: hoursString.substring(0, 30) + (hoursString.length > 30 ? '...' : '') };
      }
    };

    // Elevation Profile Component
    function ElevationProfile({ routeData, pois, useMiles, onPointClick }) {
      const canvasRef = useRef(null);
      const containerRef = useRef(null);
      const [tooltip, setTooltip] = useState(null);
      const [dimensions, setDimensions] = useState({ width: 800, height: 120 });

      const elevationData = useMemo(() => {
        if (!routeData?.coordinates) return [];
        // Sample every N points for performance
        const step = Math.max(1, Math.floor(routeData.coordinates.length / 500));
        return routeData.coordinates
          .filter((_, i) => i % step === 0 || i === routeData.coordinates.length - 1)
          .map((coord, idx, arr) => {
            const [lat, lon, ele, dist] = coord;
            // If no cumulative distance stored, estimate from index
            const estimatedDist = dist !== undefined ? dist : (routeData.distance * idx / (arr.length - 1));
            return {
              lat, lon,
              elevation: ele || 0,
              distance: estimatedDist || 0
            };
          });
      }, [routeData]);

      const stats = useMemo(() => {
        if (!elevationData.length) return { min: 0, max: 100, totalGain: 0, totalLoss: 0 };
        const elevations = elevationData.map(d => d.elevation).filter(e => e > 0);
        let gain = 0, loss = 0;
        for (let i = 1; i < elevationData.length; i++) {
          const diff = elevationData[i].elevation - elevationData[i-1].elevation;
          if (diff > 0) gain += diff;
          else loss += Math.abs(diff);
        }
        return {
          min: Math.min(...elevations) || 0,
          max: Math.max(...elevations) || 100,
          totalGain: gain,
          totalLoss: loss
        };
      }, [elevationData]);

      useEffect(() => {
        if (containerRef.current) {
          const rect = containerRef.current.getBoundingClientRect();
          setDimensions({ width: rect.width, height: 120 });
        }
      }, [routeData]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !elevationData.length) return;

        const ctx = canvas.getContext('2d');
        const { width, height } = dimensions;
        const padding = { top: 10, right: 10, bottom: 25, left: 45 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;

        canvas.width = width * 2;
        canvas.height = height * 2;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(2, 2);

        ctx.clearRect(0, 0, width, height);

        const totalDist = routeData.distance;
        const eleRange = stats.max - stats.min || 100;
        const elePadding = eleRange * 0.1;
        const minEle = stats.min - elePadding;
        const maxEle = stats.max + elePadding;

        // Draw gradient fill
        const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
        gradient.addColorStop(0, 'rgba(37, 99, 235, 0.3)');
        gradient.addColorStop(1, 'rgba(37, 99, 235, 0.05)');

        ctx.beginPath();
        ctx.moveTo(padding.left, height - padding.bottom);

        elevationData.forEach((point, i) => {
          const x = padding.left + (point.distance / totalDist) * chartWidth;
          const y = padding.top + ((maxEle - point.elevation) / (maxEle - minEle)) * chartHeight;
          if (i === 0) ctx.lineTo(x, y);
          else ctx.lineTo(x, y);
        });

        ctx.lineTo(padding.left + chartWidth, height - padding.bottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw elevation line
        ctx.beginPath();
        elevationData.forEach((point, i) => {
          const x = padding.left + (point.distance / totalDist) * chartWidth;
          const y = padding.top + ((maxEle - point.elevation) / (maxEle - minEle)) * chartHeight;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Draw POI markers - use distance-based interpolation for accurate placement
        pois.forEach(poi => {
          // Use the POI's actual distance along route for X position
          const poiDistKm = poi.distanceKm || (poi.progressRatio * totalDist);
          const x = padding.left + (poiDistKm / totalDist) * chartWidth;

          // Find elevation by interpolating between elevation data points based on distance
          let ele = stats.min;
          for (let i = 0; i < elevationData.length - 1; i++) {
            const d1 = elevationData[i].distance;
            const d2 = elevationData[i + 1].distance;
            if (poiDistKm >= d1 && poiDistKm <= d2) {
              // Linear interpolation between the two points
              const t = (d2 - d1) > 0 ? (poiDistKm - d1) / (d2 - d1) : 0;
              ele = elevationData[i].elevation + t * (elevationData[i + 1].elevation - elevationData[i].elevation);
              break;
            }
          }
          // Handle edge case where POI is at the very end
          if (poiDistKm >= elevationData[elevationData.length - 1]?.distance) {
            ele = elevationData[elevationData.length - 1]?.elevation || stats.min;
          }

          const y = padding.top + ((maxEle - ele) / (maxEle - minEle)) * chartHeight;

          ctx.beginPath();
          ctx.arc(x, y, poi.isPlannedStop ? 5 : 3, 0, Math.PI * 2);
          ctx.fillStyle = poi.isPlannedStop ? '#fcd34d' : POI_CATEGORIES[poi.category]?.color || '#6b7280';
          ctx.fill();
          if (poi.isPlannedStop) {
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });

        // Draw axes
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.lineTo(width - padding.right, height - padding.bottom);
        ctx.stroke();

        // Y-axis labels
        ctx.fillStyle = '#6b7280';
        ctx.font = '10px -apple-system, sans-serif';
        ctx.textAlign = 'right';
        const eleSteps = 4;
        for (let i = 0; i <= eleSteps; i++) {
          const ele = minEle + (maxEle - minEle) * (1 - i / eleSteps);
          const y = padding.top + (i / eleSteps) * chartHeight;
          const label = useMiles ? `${Math.round(mToFt(ele))}ft` : `${Math.round(ele)}m`;
          ctx.fillText(label, padding.left - 5, y + 3);
        }

        // X-axis labels
        ctx.textAlign = 'center';
        const distSteps = 5;
        for (let i = 0; i <= distSteps; i++) {
          const dist = (totalDist * i) / distSteps;
          const x = padding.left + (i / distSteps) * chartWidth;
          const label = useMiles ? `${kmToMi(dist).toFixed(0)}` : `${dist.toFixed(0)}`;
          ctx.fillText(label, x, height - 8);
        }
        ctx.fillText(useMiles ? 'miles' : 'km', width - padding.right - 15, height - 8);

      }, [elevationData, dimensions, pois, stats, useMiles]);

      const handleMouseMove = (e) => {
        if (!containerRef.current || !elevationData.length || !routeData) return;
        const rect = containerRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const padding = { left: 45, right: 10, top: 10, bottom: 25 };
        const chartWidth = dimensions.width - padding.left - padding.right;
        const chartHeight = dimensions.height - padding.top - padding.bottom;

        if (x < padding.left || x > dimensions.width - padding.right) {
          setTooltip(null);
          return;
        }

        // Convert X position to distance along route
        const progress = (x - padding.left) / chartWidth;
        const totalDist = routeData.distance;
        const hoverDist = progress * totalDist;

        // Find elevation by interpolating between data points based on distance
        let elevation = stats.min;
        let foundPoint = null;

        for (let i = 0; i < elevationData.length - 1; i++) {
          const d1 = elevationData[i].distance;
          const d2 = elevationData[i + 1].distance;
          if (hoverDist >= d1 && hoverDist <= d2) {
            // Linear interpolation between the two points
            const t = (d2 - d1) > 0 ? (hoverDist - d1) / (d2 - d1) : 0;
            elevation = elevationData[i].elevation + t * (elevationData[i + 1].elevation - elevationData[i].elevation);
            foundPoint = {
              distance: hoverDist,
              elevation: elevation,
              lat: elevationData[i].lat + t * (elevationData[i + 1].lat - elevationData[i].lat),
              lon: elevationData[i].lon + t * (elevationData[i + 1].lon - elevationData[i].lon)
            };
            break;
          }
        }

        // Handle edge case at the very end
        if (!foundPoint && hoverDist >= elevationData[elevationData.length - 1]?.distance) {
          foundPoint = elevationData[elevationData.length - 1];
          elevation = foundPoint?.elevation || stats.min;
        }

        // Handle edge case at the very beginning
        if (!foundPoint && hoverDist <= elevationData[0]?.distance) {
          foundPoint = elevationData[0];
          elevation = foundPoint?.elevation || stats.min;
        }

        if (foundPoint || elevation) {
          const dist = useMiles ? kmToMi(hoverDist).toFixed(1) : hoverDist.toFixed(1);
          const ele = useMiles ? Math.round(mToFt(elevation)) : Math.round(elevation);

          // Calculate Y position for the dot using same formula as canvas drawing
          const eleRange = stats.max - stats.min || 100;
          const elePadding = eleRange * 0.1;
          const minEle = stats.min - elePadding;
          const maxEle = stats.max + elePadding;
          const y = padding.top + ((maxEle - elevation) / (maxEle - minEle)) * chartHeight;

          setTooltip({
            x,
            y,
            text: `${dist} ${useMiles ? 'mi' : 'km'} ‚Ä¢ ${ele} ${useMiles ? 'ft' : 'm'}`,
            lat: foundPoint?.lat,
            lon: foundPoint?.lon
          });
        }
      };

      const handleClick = (e) => {
        if (!containerRef.current || !elevationData.length || !onPointClick) return;
        const rect = containerRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const padding = { left: 45, right: 10 };
        const chartWidth = dimensions.width - padding.left - padding.right;

        if (x < padding.left || x > dimensions.width - padding.right) return;

        const progress = (x - padding.left) / chartWidth;
        const idx = Math.floor(progress * (elevationData.length - 1));
        const point = elevationData[idx];

        if (point) {
          onPointClick(point.lat, point.lon);
        }
      };

      const totalGain = useMiles ? Math.round(mToFt(stats.totalGain)) : Math.round(stats.totalGain);
      const totalLoss = useMiles ? Math.round(mToFt(stats.totalLoss)) : Math.round(stats.totalLoss);
      const minEle = useMiles ? Math.round(mToFt(stats.min)) : Math.round(stats.min);
      const maxEle = useMiles ? Math.round(mToFt(stats.max)) : Math.round(stats.max);
      const unit = useMiles ? 'ft' : 'm';

      return (
        <div className="elevation-profile">
          <h4><Icons.Mountain /> Elevation Profile</h4>
          <div
            ref={containerRef}
            className="elevation-chart"
            onMouseMove={handleMouseMove}
            onMouseLeave={() => setTooltip(null)}
            onClick={handleClick}
          >
            <canvas ref={canvasRef} className="elevation-canvas" />
            {tooltip && (
              <>
                <div className="elevation-hover-dot" style={{ left: tooltip.x, top: tooltip.y }} />
                <div className="elevation-tooltip" style={{ left: tooltip.x, top: -30 }}>
                  {tooltip.text}
                </div>
              </>
            )}
          </div>
          <div className="elevation-stats">
            <span>‚Üë {totalGain.toLocaleString()} {unit} gain</span>
            <span>‚Üì {totalLoss.toLocaleString()} {unit} loss</span>
            <span>Min: {minEle.toLocaleString()} {unit}</span>
            <span>Max: {maxEle.toLocaleString()} {unit}</span>
          </div>
        </div>
      );
    }

    // Featured Routes Data
    // GPX URLs should point to your Netlify-hosted files (e.g., https://scout.midwestultracycling.com/routes/...)
    const FEATURED_ROUTES = [
      {
        id: 'mishigami',
        name: 'Mishigami',
        distance: 1121,
        elevation: 26000,
        location: 'Chicago, IL, USA',
        date: 'July 11th, 2026',
        description: 'A 1,121-mile circumnavigation of Lake Michigan. This epic route follows the Great Lakes shoreline through forests, dunes, and charming small towns.',
        image: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800&h=400&fit=crop',
        badge: 'Featured Race',
        gpxUrl: '/routes/mishigami-main-event.gpx',
        color: '#00417C',
        hasGpx: true
      },
     {
       id: 'mini-gami',
       name: 'Mini-Gami',
       distance: 484,
       elevation: 10000,
       location: 'Chicago, IL, USA',
       date: 'July 11th, 2026',
       description: 'The shorter sibling to Mishigami utilizing the ferry to cut across the lake.',
       image: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800&h=400&fit=crop',
       badge: 'Featured Race',
       gpxUrl: '/routes/mini-gami.gpx',
       color: '#00417C',
       hasGpx: true
     },
      {
        id: 'driftless-dagger',
        name: 'Driftless Dagger',
        distance: 550,
        elevation: 40000,
        location: 'Galena, IL, USA',
        date: 'October 3, 2026',
        description: 'Rugged gravel roads, steep ascents, and peaceful backcountry stretches meet the raw beauty of the Driftless Region. Death by a Thousand Cuts.',
        image: 'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=800&h=400&fit=crop',
        badge: 'Featured Race',
        gpxUrl: '/routes/driftless-dagger.gpx',
        color: '#6B2424',
        hasGpx: true // GPX available but needs hosting
      },
      {
        id: 'baby-dagger',
        name: 'Baby Dagger',
        distance: 237,
        elevation: 20000,
        location: 'Galena, IL',
        date: 'October 3, 2026',
        description: 'The shorter sibling of the Driftless Dagger. Same start/finish at Chestnut Mountain Resort, same challenging terrain, half the distance.',
        image: 'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=800&h=400&fit=crop',
        badge: 'Dagger Series',
        gpxUrl: '/routes/baby-dagger.gpx', // TODO: Add URL when hosted
        color: '#277521',
        hasGpx: true
      }
    ];

    // Fetch GPX from URL (for pre-loaded featured routes)
    async function fetchGpxFromUrl(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch GPX: ${response.status} ${response.statusText}`);
      }
      const text = await response.text();
      return text;
    }

    // Main App
    function App() {
      const [currentView, setCurrentView] = useState('home'); // 'home' or 'planner'
      const [selectedFeaturedRoute, setSelectedFeaturedRoute] = useState(null);
      const [inputMode, setInputMode] = useState('file');
      const [routeUrl, setRouteUrl] = useState('');
      const [useMiles, setUseMiles] = useState(() => {
        try {
          return localStorage.getItem(UNITS_KEY) !== 'km';
        } catch { return true; }
      });
      const [avgSpeed, setAvgSpeed] = useState(16); // Always stored in km/h internally
      const [startDate, setStartDate] = useState(new Date().toISOString().split('T')[0]);
      const [startTime, setStartTime] = useState('07:00');
      const [isLoading, setIsLoading] = useState(false);
      const [loadingStep, setLoadingStep] = useState('');
      const [loadingSteps, setLoadingSteps] = useState([]);
      const [loadingProgress, setLoadingProgress] = useState(0); // 0-100
      const [error, setError] = useState(null);
      const [routeData, setRouteData] = useState(null);
      const [pois, setPois] = useState([]);
      const [plannedStops, setPlannedStops] = useState({}); // { poiId: minutes }
      const [possibleStops, setPossibleStops] = useState({}); // { poiId: true } - marked as potential stop
      const [maxDetourDistance, setMaxDetourDistance] = useState(1500); // meters - max distance off route to show
      const [activeView, setActiveView] = useState('timeline');
      const [viewMode, setViewMode] = useState('full'); // 'full' or 'condensed'
      const [activeFilters, setActiveFilters] = useState(Object.keys(POI_CATEGORIES));
      const [searchCategories, setSearchCategories] = useState(Object.keys(POI_CATEGORIES)); // Categories to search on upload
      const [showExport, setShowExport] = useState(false);
      const [dragOver, setDragOver] = useState(false);
      const [history, setHistory] = useState([]);
      const [expandedStopId, setExpandedStopId] = useState(null); // For condensed view popover

      const mapRef = useRef(null);
      const mapInstanceRef = useRef(null);
      const markersRef = useRef([]);
      const mileMarkersRef = useRef([]);
      const highlightMarkerRef = useRef(null);
      const fileInputRef = useRef(null);
      const plannedStopsSectionRef = useRef(null);
      const mapSectionRef = useRef(null);

      const [showViewPlanButton, setShowViewPlanButton] = useState(false);

      // Save unit preference
      useEffect(() => {
        try {
          localStorage.setItem(UNITS_KEY, useMiles ? 'mi' : 'km');
        } catch {}
      }, [useMiles]);

      useEffect(() => {
        setHistory(getHistory());
      }, []);

      // Show/hide View Plan floating button based on scroll position
      useEffect(() => {
        if (!routeData) {
          setShowViewPlanButton(false);
          return;
        }

        const handleScroll = () => {
          const mapSection = mapSectionRef.current;
          if (!mapSection) return;

          const rect = mapSection.getBoundingClientRect();
          // Show button when map section is scrolled out of view (top is above viewport)
          const shouldShow = rect.bottom < 100 && Object.keys(plannedStops).length > 0;
          setShowViewPlanButton(shouldShow);
        };

        window.addEventListener('scroll', handleScroll, { passive: true });
        handleScroll(); // Check initial state

        return () => window.removeEventListener('scroll', handleScroll);
      }, [routeData, plannedStops]);

      const scrollToPlannedStops = () => {
        plannedStopsSectionRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      };

      const getStartDateTime = () => {
        const [year, month, day] = startDate.split('-').map(Number);
        const [hours, minutes] = startTime.split(':').map(Number);
        return new Date(year, month - 1, day, hours, minutes);
      };

      const totalStopMinutes = useMemo(() =>
        Object.values(plannedStops).reduce((sum, mins) => sum + mins, 0),
        [plannedStops]
      );

      const getEndDateTime = () => {
        if (!routeData) return null;
        const start = getStartDateTime();
        const ridingHours = routeData.distance / avgSpeed;
        const totalHours = ridingHours + (totalStopMinutes / 60);
        return new Date(start.getTime() + totalHours * 60 * 60 * 1000);
      };

      const enrichedPOIs = useMemo(() => {
        if (!routeData || pois.length === 0) return [];
        return enrichPOIs(pois, routeData.distance, getStartDateTime(), avgSpeed, plannedStops, possibleStops);
      }, [pois, routeData, avgSpeed, startDate, startTime, plannedStops, possibleStops]);

      const filteredPOIs = useMemo(() =>
        enrichedPOIs.filter(p =>
          activeFilters.includes(p.category) &&
          p.distanceOffRoute <= maxDetourDistance
        ),
        [enrichedPOIs, activeFilters, maxDetourDistance]
      );

      const plannedStopsCount = Object.keys(plannedStops).filter(id => plannedStops[id] > 0).length;
      const possibleStopsCount = Object.keys(possibleStops).filter(id => possibleStops[id]).length;
      const totalSelectedCount = plannedStopsCount + possibleStopsCount;

      // Get all selected stops (both planned and possible) for summary
      const selectedStops = useMemo(() => {
        return enrichedPOIs.filter(p => p.isPlannedStop || p.isPossibleStop)
          .sort((a, b) => a.progressRatio - b.progressRatio);
      }, [enrichedPOIs]);

      // Format distance based on unit preference
      const formatDistance = (km, decimals = 1) => {
        if (useMiles) {
          return `${kmToMi(km).toFixed(decimals)} mi`;
        }
        return `${km.toFixed(decimals)} km`;
      };

      // Format elevation based on unit preference
      const formatElevation = (meters) => {
        if (useMiles) {
          return `${Math.round(mToFt(meters)).toLocaleString()} ft`;
        }
        return `${Math.round(meters).toLocaleString()} m`;
      };

      // Format speed based on unit preference
      const formatSpeed = (kmh) => {
        if (useMiles) {
          return `${kmToMi(kmh).toFixed(1)} mph`;
        }
        return `${kmh.toFixed(1)} km/h`;
      };

      // Format detour distance
      const formatDetour = (meters) => {
        if (useMiles) {
          const feet = mToFt(meters);
          if (feet < 500) return `${Math.round(feet)} ft off route`;
          return `${(feet / 5280).toFixed(1)} mi off route`;
        }
        if (meters < 100) return `${Math.round(meters)} m off route`;
        return `${(meters / 1000).toFixed(1)} km off route`;
      };

      // Get display distance value (for stat cards)
      const getDisplayDistance = (km) => {
        return useMiles ? kmToMi(km).toFixed(1) : km.toFixed(1);
      };

      const getDisplayElevation = (meters) => {
        return useMiles ? Math.round(mToFt(meters)).toLocaleString() : Math.round(meters).toLocaleString();
      };

      const togglePlannedStop = (poiId) => {
        setPlannedStops(prev => {
          const current = prev[poiId] || 0;
          if (current > 0) {
            const { [poiId]: removed, ...rest } = prev;
            return rest;
          } else {
            const currentCount = Object.keys(prev).filter(id => prev[id] > 0).length;
            if (currentCount >= MAX_PLANNED_STOPS) {
              alert(`Maximum ${MAX_PLANNED_STOPS} planned stops allowed`);
              return prev;
            }
            // Remove from possible stops if adding to planned
            setPossibleStops(ps => {
              const { [poiId]: removed, ...rest } = ps;
              return rest;
            });
            return { ...prev, [poiId]: 15 };
          }
        });
      };

      const togglePossibleStop = (poiId) => {
        // If it's already a planned stop, don't allow marking as possible
        if (plannedStops[poiId] > 0) return;

        setPossibleStops(prev => {
          if (prev[poiId]) {
            const { [poiId]: removed, ...rest } = prev;
            return rest;
          }
          return { ...prev, [poiId]: true };
        });
      };

      const removeSelectedStop = (poiId) => {
        // Remove from both planned and possible stops
        setPlannedStops(prev => {
          const { [poiId]: removed, ...rest } = prev;
          return rest;
        });
        setPossibleStops(prev => {
          const { [poiId]: removed, ...rest } = prev;
          return rest;
        });
      };

      const updateStopTime = (poiId, minutes) => {
        const mins = Math.max(0, Math.min(480, parseInt(minutes) || 0));
        setPlannedStops(prev => {
          if (mins === 0) {
            const { [poiId]: removed, ...rest } = prev;
            return rest;
          }
          return { ...prev, [poiId]: mins };
        });
      };

      // Convert possible stop to planned stop
      const convertToPlanedStop = (poiId) => {
        setPossibleStops(prev => {
          const { [poiId]: removed, ...rest } = prev;
          return rest;
        });
        setPlannedStops(prev => ({ ...prev, [poiId]: 15 }));
      };

      const handleFile = async (file) => {
        if (!file) return;

        if (searchCategories.length === 0) {
          setError('Please select at least one resource type to search.');
          return;
        }

        setError(null);
        setIsLoading(true);
        setLoadingProgress(0);
        setPlannedStops({});
        setPossibleStops({});
        setRouteData(null);
        setPois([]);

        const fileSize = (file.size / 1024 / 1024).toFixed(1);
        const isLargeFile = file.size > 500000; // > 500KB
        const categoryLabels = searchCategories.map(c => POI_CATEGORIES[c]?.label).filter(Boolean).join(', ');

        setLoadingSteps([
          { id: 'parse', label: 'Parsing GPX file', detail: `${file.name} (${fileSize}MB)`, status: 'active' },
          { id: 'pois', label: 'Querying OpenStreetMap', detail: `Searching: ${categoryLabels}`, status: 'pending' },
          { id: 'process', label: 'Processing results', detail: 'Calculating distances and filtering', status: 'pending' }
        ]);
        setLoadingStep('Reading GPX file...');
        setLoadingProgress(5);

        try {
          // Use setTimeout to allow UI to update before heavy parsing
          await new Promise(resolve => setTimeout(resolve, 50));

          const text = await file.text();
          setLoadingStep('Extracting track points...');
          setLoadingProgress(15);

          const route = parseGPX(text);

          if (route.coordinates.length < 2) {
            throw new Error('GPX file contains no valid track points');
          }

          const routeInfo = `${route.distance.toFixed(0)}km ‚Ä¢ ${route.totalPoints || route.coordinates.length} points`;
          console.log(`Parsed: ${routeInfo}`);
          setLoadingProgress(25);

          setRouteData(route);

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'parse' ? { ...s, status: 'done', label: 'GPX parsed successfully', detail: routeInfo } :
            s.id === 'pois' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Connecting to OpenStreetMap...');
          setLoadingProgress(30);

          // Allow UI to update before POI fetch
          await new Promise(resolve => setTimeout(resolve, 50));

          let rawPois = [];
          let segmentCount = 1;
          try {
            rawPois = await fetchPOIs(route.coordinates, (msg) => {
              setLoadingStep(msg);
              // Handle segment progress messages
              if (msg.includes('Processing') && msg.includes('segments')) {
                const match = msg.match(/(\d+) route segments/);
                if (match) segmentCount = parseInt(match[1]);
                setLoadingProgress(35);
                setLoadingSteps(prev => prev.map(s =>
                  s.id === 'pois' ? { ...s, detail: `Batch query: ${segmentCount} segments` } : s
                ));
              } else if (msg.includes('Segment') && msg.includes('complete')) {
                const match = msg.match(/Segment (\d+)\/(\d+)/);
                if (match) {
                  const current = parseInt(match[1]);
                  const total = parseInt(match[2]);
                  const progress = 35 + (current / total) * 40; // 35-75%
                  setLoadingProgress(Math.round(progress));
                }
              } else if (msg.includes('Querying')) {
                setLoadingProgress(40);
              } else if (msg.includes('Processing POI')) {
                setLoadingProgress(75);
              }
            }, searchCategories);
          } catch (poiErr) {
            console.error('POI fetch error:', poiErr);
            setError('Could not fetch POIs from OpenStreetMap. The route is loaded - you can try refreshing to fetch POIs again.');
          }

          setLoadingProgress(85);

          // Handle 0 POIs case with helpful message
          if (rawPois.length === 0) {
            setError(
              'No resources found along this route. This may happen if: (1) The route passes through areas with limited OpenStreetMap data, ' +
              '(2) The OpenStreetMap servers were busy, or (3) The route is unusually remote. Try clicking "Re-scan Route" to try again.'
            );
          }

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'pois' ? { ...s, status: 'done', label: 'Resources found', detail: `${rawPois.length} locations${segmentCount > 1 ? ` (${segmentCount} segments)` : ''}` } :
            s.id === 'process' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Calculating distances from route...');

          setPois(rawPois);
          setActiveFilters([...searchCategories]);
          setLoadingProgress(95);

          setLoadingStep('Saving to history...');
          const updatedHistory = saveToHistory(route, rawPois);
          setHistory(updatedHistory);

          setLoadingSteps(prev => prev.map(s => ({ ...s, status: 'done' })));
          setLoadingProgress(100);

        } catch (err) {
          console.error('File processing error:', err);
          setError(err.message || 'Failed to process route');
        } finally {
          setIsLoading(false);
          setLoadingProgress(0);
        }
      };

      const loadFromHistory = async (entry) => {
        if (searchCategories.length === 0) {
          setError('Please select at least one resource type to search.');
          return;
        }

        setError(null);
        setIsLoading(true);
        setLoadingProgress(0);
        setPlannedStops({});
        setPossibleStops({});

        const categoryLabels = searchCategories.map(c => POI_CATEGORIES[c]?.label).filter(Boolean).join(', ');

        setLoadingSteps([
          { id: 'load', label: 'Loading saved route', detail: entry.name, status: 'active' },
          { id: 'pois', label: 'Querying OpenStreetMap', detail: `Searching: ${categoryLabels}`, status: 'pending' },
          { id: 'process', label: 'Processing results', detail: 'Calculating distances and filtering', status: 'pending' }
        ]);
        setLoadingStep('Restoring route data...');
        setLoadingProgress(10);

        try {
          setRouteData(entry.routeData);
          setLoadingProgress(25);

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'load' ? { ...s, status: 'done', label: 'Route loaded', detail: `${entry.distance?.toFixed(0) || '?'}km ‚Ä¢ ${entry.routeData?.coordinates?.length || '?'} points` } :
            s.id === 'pois' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Connecting to OpenStreetMap...');
          setLoadingProgress(30);

          // Re-fetch POIs with current maxDetourDistance setting
          let rawPois = [];
          try {
            rawPois = await fetchPOIs(entry.routeData.coordinates, (msg) => {
              setLoadingStep(msg);
              if (msg.includes('Querying')) setLoadingProgress(45);
              if (msg.includes('Processing')) setLoadingProgress(75);
            }, searchCategories);
          } catch (poiErr) {
            console.error('POI fetch error:', poiErr);
            rawPois = entry.poisData || [];
            setError('Could not refresh POIs. Using cached data.');
          }

          setLoadingProgress(85);
          setLoadingSteps(prev => prev.map(s =>
            s.id === 'pois' ? { ...s, status: 'done', label: 'Resources found', detail: `${rawPois.length} locations within search area` } :
            s.id === 'process' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Calculating distances from route...');

          setPois(rawPois);
          setActiveFilters([...searchCategories]);
          setLoadingProgress(95);
          setLoadingSteps(prev => prev.map(s => ({ ...s, status: 'done' })));
          setLoadingProgress(100);

        } catch (err) {
          console.error('Load history error:', err);
          setError(err.message || 'Failed to load route');
        } finally {
          setIsLoading(false);
          setLoadingProgress(0);
        }
      };

      const handleDeleteHistory = (e, id) => {
        e.stopPropagation();
        const updated = deleteFromHistory(id);
        setHistory(updated);
      };

      const handleUrlSubmit = async () => {
        if (!routeUrl.trim()) return;
        setError(null);

        const rwgpsMatch = routeUrl.match(/ridewithgps\.com\/routes\/(\d+)/);
        const stravaMatch = routeUrl.match(/strava\.com\/routes\/(\d+)/);

        if (!rwgpsMatch && !stravaMatch) {
          setError('Please enter a valid RideWithGPS or Strava route URL');
          return;
        }

        const platform = rwgpsMatch ? 'RideWithGPS' : 'Strava';
        setError(`Due to ${platform}'s API restrictions, please export your route as a GPX file and upload it here. On ${platform}, open your route and click "Export" or "Download GPX".`);
      };

      const handleDragOver = (e) => { e.preventDefault(); setDragOver(true); };
      const handleDragLeave = () => setDragOver(false);
      const handleDrop = (e) => {
        e.preventDefault();
        setDragOver(false);
        const file = e.dataTransfer.files[0];
        if (file && (file.name.endsWith('.gpx') || file.type === 'application/gpx+xml')) {
          handleFile(file);
        } else {
          setError('Please upload a GPX file');
        }
      };

      // Handle click on elevation profile
      const handleElevationClick = useCallback((lat, lon) => {
        if (!mapInstanceRef.current) return;

        // Remove existing highlight
        if (highlightMarkerRef.current) {
          highlightMarkerRef.current.remove();
        }

        // Add highlight marker
        const icon = L.divIcon({
          className: 'highlight-marker',
          html: '<div style="width:16px;height:16px;background:#ef4444;border:3px solid white;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>',
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        });

        highlightMarkerRef.current = L.marker([lat, lon], { icon })
          .addTo(mapInstanceRef.current);

        // Pan to location
        mapInstanceRef.current.panTo([lat, lon]);

        // Auto-remove after 5 seconds
        setTimeout(() => {
          if (highlightMarkerRef.current) {
            highlightMarkerRef.current.remove();
            highlightMarkerRef.current = null;
          }
        }, 5000);
      }, []);

      // Initialize map
      useEffect(() => {
        if (!routeData || !mapRef.current) return;

        if (mapInstanceRef.current) {
          mapInstanceRef.current.remove();
          mapInstanceRef.current = null;
        }

        // Small delay to ensure DOM is ready
        const initMap = () => {
          if (!mapRef.current) return;

          try {
            const midIdx = Math.floor(routeData.coordinates.length / 2);
            const map = L.map(mapRef.current).setView(
              [routeData.coordinates[midIdx][0], routeData.coordinates[midIdx][1]],
              10
            );

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '¬© OpenStreetMap'
            }).addTo(map);

            const routeCoords = routeData.coordinates.map(([lat, lon]) => [lat, lon]);
            const routeLine = L.polyline(routeCoords, {
              color: '#00417C', // Mishigami Deep Blue
              weight: 4,
              opacity: 0.8
            }).addTo(map);

            map.fitBounds(routeLine.getBounds(), { padding: [50, 50] });
            mapInstanceRef.current = map;

            // Add zoom listener for mile markers - use inline function to avoid stale closure
            const handleZoomEnd = () => {
              if (!mapInstanceRef.current || !routeData) return;

              // Clear existing markers
              mileMarkersRef.current.forEach(m => m.remove());
              mileMarkersRef.current = [];

              const currentMap = mapInstanceRef.current;
              const zoom = currentMap.getZoom();
              const currentUseMiles = localStorage.getItem(UNITS_KEY) !== 'km';

              let intervalKm;
              if (zoom >= 13) {
                intervalKm = currentUseMiles ? miToKm(1) : 1;
              } else if (zoom >= 11) {
                intervalKm = currentUseMiles ? miToKm(5) : 5;
              } else {
                intervalKm = currentUseMiles ? miToKm(10) : 10;
              }

              const totalDist = routeData.distance;
              const coords = routeData.coordinates;

              // Check if coordinates have cumulative distance (4th element)
              const hasCumulativeDist = coords.length > 0 && coords[0].length >= 4;
              if (!hasCumulativeDist) return; // Skip mile markers for legacy data

              for (let dist = intervalKm; dist < totalDist; dist += intervalKm) {
                let targetIdx = 0;
                for (let i = 0; i < coords.length; i++) {
                  if ((coords[i][3] || 0) >= dist) {
                    targetIdx = i;
                    break;
                  }
                }

                if (targetIdx > 0 && targetIdx < coords.length) {
                  const [lat, lon] = coords[targetIdx];
                  const displayDist = currentUseMiles ? Math.round(kmToMi(dist)) : Math.round(dist);
                  const unit = currentUseMiles ? 'mi' : 'km';

                  const icon = L.divIcon({
                    className: 'mile-marker',
                    html: `<div class="mile-marker-icon">${displayDist} ${unit}</div>`,
                    iconSize: [40, 20],
                    iconAnchor: [20, 10]
                  });

                  const marker = L.marker([lat, lon], { icon, interactive: false })
                    .addTo(currentMap);
                  mileMarkersRef.current.push(marker);
                }
              }
            };

            map.on('zoomend', handleZoomEnd);
            handleZoomEnd();
          } catch (err) {
            console.error('Map initialization error:', err);
          }
        };

        // Use requestAnimationFrame to ensure DOM is ready
        requestAnimationFrame(initMap);

        return () => {
          if (mapInstanceRef.current) {
            mapInstanceRef.current.remove();
            mapInstanceRef.current = null;
          }
        };
      }, [routeData]);

      // Update mile markers when units change
      useEffect(() => {
        if (!mapInstanceRef.current || !routeData) return;

        // Clear and redraw mile markers
        mileMarkersRef.current.forEach(m => m.remove());
        mileMarkersRef.current = [];

        const map = mapInstanceRef.current;
        const zoom = map.getZoom();

        let intervalKm;
        if (zoom >= 13) {
          intervalKm = useMiles ? miToKm(1) : 1;
        } else if (zoom >= 11) {
          intervalKm = useMiles ? miToKm(5) : 5;
        } else {
          intervalKm = useMiles ? miToKm(10) : 10;
        }

        const totalDist = routeData.distance;
        const coords = routeData.coordinates;

        // Check if coordinates have cumulative distance (4th element)
        const hasCumulativeDist = coords.length > 0 && coords[0].length >= 4;
        if (!hasCumulativeDist) return; // Skip mile markers for legacy data

        for (let dist = intervalKm; dist < totalDist; dist += intervalKm) {
          let targetIdx = 0;
          for (let i = 0; i < coords.length; i++) {
            if ((coords[i][3] || 0) >= dist) {
              targetIdx = i;
              break;
            }
          }

          if (targetIdx > 0 && targetIdx < coords.length) {
            const [lat, lon] = coords[targetIdx];
            const displayDist = useMiles ? Math.round(kmToMi(dist)) : Math.round(dist);
            const unit = useMiles ? 'mi' : 'km';

            const icon = L.divIcon({
              className: 'mile-marker',
              html: `<div class="mile-marker-icon">${displayDist} ${unit}</div>`,
              iconSize: [40, 20],
              iconAnchor: [20, 10]
            });

            const marker = L.marker([lat, lon], { icon, interactive: false })
              .addTo(map);
            mileMarkersRef.current.push(marker);
          }
        }
      }, [useMiles, routeData]);

      // Update markers
      useEffect(() => {
        if (!mapInstanceRef.current || !routeData) return;

        markersRef.current.forEach(m => m.remove());
        markersRef.current = [];

        filteredPOIs.forEach(poi => {
          // Skip POIs with invalid coordinates
          if (!poi.coordinates || !Array.isArray(poi.coordinates) ||
              poi.coordinates.length < 2 ||
              typeof poi.coordinates[0] !== 'number' ||
              typeof poi.coordinates[1] !== 'number' ||
              isNaN(poi.coordinates[0]) || isNaN(poi.coordinates[1])) {
            console.warn('Skipping POI with invalid coordinates:', poi.name);
            return;
          }

          const cat = POI_CATEGORIES[poi.category];
          const iconHtml = poi.category === 'water' ? 'üíß' :
                          poi.category === 'camp' ? '‚õ∫' :
                          poi.category === 'food' ? 'üç¥' :
                          poi.category === 'store' ? 'üè™' : 'üì∏';

          const isPlanned = poi.isPlannedStop;
          const isPossible = poi.isPossibleStop;

          // Enhanced styling for planned and possible stops
          let markerHtml;
          if (isPlanned) {
            markerHtml = `<div style="width:32px;height:32px;background:${cat.bgColor};border:3px solid #fcd34d;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:14px;box-shadow:0 0 0 3px #78350f,0 4px 8px rgba(0,0,0,0.3);">${iconHtml}</div>`;
          } else if (isPossible) {
            markerHtml = `<div style="width:30px;height:30px;background:${cat.bgColor};border:3px solid #3b82f6;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:14px;box-shadow:0 0 0 2px #1e40af,0 3px 6px rgba(0,0,0,0.2);">${iconHtml}</div>`;
          } else {
            markerHtml = `<div style="width:26px;height:26px;background:${cat.bgColor};border:2px solid ${cat.color};border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:13px;">${iconHtml}</div>`;
          }

          const icon = L.divIcon({
            className: 'custom-marker',
            html: markerHtml,
            iconSize: isPlanned ? [32, 32] : isPossible ? [30, 30] : [26, 26],
            iconAnchor: isPlanned ? [16, 16] : isPossible ? [15, 15] : [13, 13]
          });

          const osmUrl = `https://www.openstreetmap.org/${poi.osmType}/${poi.osmId}`;
          const gmapsUrl = `https://www.google.com/maps/search/?api=1&query=${poi.coordinates[0]},${poi.coordinates[1]}`;
          const detourText = poi.distanceOffRoute < 50 ? 'On route' : formatDetour(poi.distanceOffRoute);
          const distText = useMiles ? `Mile ${kmToMi(poi.distanceKm).toFixed(1)}` : `Km ${poi.distanceKm.toFixed(1)}`;

          // Create unique button IDs for this POI
          const plannedBtnId = `planned-btn-${poi.id}`;
          const possibleBtnId = `possible-btn-${poi.id}`;

          const marker = L.marker(poi.coordinates, { icon, zIndexOffset: isPlanned ? 1000 : isPossible ? 500 : 0 })
            .addTo(mapInstanceRef.current)
            .bindPopup(`
              <div class="popup-title">${poi.name}</div>
              <div class="popup-meta">${poi.type}</div>
              <div class="popup-meta">ETA: ${formatTime(poi.eta)} ‚Ä¢ ${distText}</div>
              <div class="popup-meta">${detourText}</div>
              ${isPlanned ? '<div class="popup-meta" style="color:#d97706;font-weight:600;">‚è± Planned stop: ' + poi.stopMinutes + ' min</div>' : ''}
              ${isPossible ? '<div class="popup-meta" style="color:#1e40af;font-weight:600;">üìå Possible stop</div>' : ''}
              <div style="display:flex;gap:6px;margin:8px 0;">
                <button id="${plannedBtnId}" style="padding:4px 8px;font-size:11px;border-radius:4px;border:1px solid ${isPlanned ? '#fcd34d' : '#d1d5db'};background:${isPlanned ? '#fef3c7' : 'white'};cursor:pointer;">
                  ${isPlanned ? '‚úì Planned' : '+ Planned'}
                </button>
                <button id="${possibleBtnId}" style="padding:4px 8px;font-size:11px;border-radius:4px;border:1px solid ${isPossible ? '#93c5fd' : '#d1d5db'};background:${isPossible ? '#dbeafe' : 'white'};cursor:pointer;" ${isPlanned ? 'disabled' : ''}>
                  ${isPossible ? '‚úì Possible' : '+ Possible'}
                </button>
              </div>
              <div class="popup-links">
                <a href="${osmUrl}" target="_blank" class="popup-link">OSM ‚Üó</a>
                <a href="${gmapsUrl}" target="_blank" class="popup-link gmaps">Google Maps ‚Üó</a>
              </div>
            `);

          // Add event listeners for popup buttons
          marker.on('popupopen', () => {
            const plannedBtn = document.getElementById(plannedBtnId);
            const possibleBtn = document.getElementById(possibleBtnId);

            if (plannedBtn) {
              plannedBtn.onclick = () => togglePlannedStop(poi.id);
            }
            if (possibleBtn) {
              possibleBtn.onclick = () => togglePossibleStop(poi.id);
            }
          });

          markersRef.current.push(marker);
        });

        // Start marker - extract just [lat, lon] from coordinates
        const startCoord = routeData.coordinates[0];
        const endCoord = routeData.coordinates[routeData.coordinates.length - 1];

        if (startCoord && startCoord.length >= 2) {
          const startIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="width:30px;height:30px;background:#16a34a;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:14px;">S</div>',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          });
          markersRef.current.push(
            L.marker([startCoord[0], startCoord[1]], { icon: startIcon })
              .addTo(mapInstanceRef.current)
              .bindPopup(`<div class="popup-title">Start</div><div class="popup-meta">${formatTime(getStartDateTime())}</div>`)
          );
        }

        // End marker
        if (endCoord && endCoord.length >= 2) {
          const endIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="width:30px;height:30px;background:#dc2626;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:14px;">F</div>',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          });
          markersRef.current.push(
            L.marker([endCoord[0], endCoord[1]], { icon: endIcon })
              .addTo(mapInstanceRef.current)
              .bindPopup(`<div class="popup-title">Finish</div><div class="popup-meta">${formatTime(getEndDateTime())}</div>`)
          );
        }

      }, [filteredPOIs, routeData, plannedStops, possibleStops, useMiles]);

      const toggleFilter = (cat) => {
        setActiveFilters(prev =>
          prev.includes(cat) ? prev.filter(f => f !== cat) : [...prev, cat]
        );
      };

      const poiCounts = useMemo(() => {
        const counts = {};
        Object.keys(POI_CATEGORIES).forEach(cat => {
          counts[cat] = enrichedPOIs.filter(p => p.category === cat).length;
        });
        return counts;
      }, [enrichedPOIs]);

      // Export functions - only export selected stops (planned + possible)
      const exportGPX = () => {
        if (!routeData) return;

        // Only include selected stops in export
        const stopsToExport = selectedStops;

        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="RouteScout" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${routeData.name}</name>
    <time>${new Date().toISOString()}</time>
  </metadata>
  <trk>
    <name>${routeData.name}</name>
    <trkseg>
${routeData.coordinates.map(([lat, lon, ele]) => `      <trkpt lat="${lat}" lon="${lon}">${ele ? `<ele>${ele}</ele>` : ''}</trkpt>`).join('\n')}
    </trkseg>
  </trk>
${stopsToExport.map(poi => `  <wpt lat="${poi.coordinates[0]}" lon="${poi.coordinates[1]}">
    <name>${poi.name}${poi.isPlannedStop ? ' [PLANNED]' : poi.isPossibleStop ? ' [POSSIBLE]' : ''}</name>
    <desc>${poi.type} - ETA: ${formatTime(poi.eta)} - ${formatDistance(poi.distanceKm)} - ${formatDetour(poi.distanceOffRoute)}${poi.isPlannedStop ? ' - Stop: ' + poi.stopMinutes + ' min' : ''}</desc>
    <type>${poi.category}</type>
  </wpt>`).join('\n')}
</gpx>`;

        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${routeData.name.replace(/[^a-z0-9]/gi, '-')}-trip-plan.gpx`;
        a.click();
        URL.revokeObjectURL(url);
        setShowExport(false);
      };

      const exportPDF = async () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4'); // A4 portrait
        const pageWidth = 210;
        const pageHeight = 297;
        const margin = 12;
        const colWidth = (pageWidth - margin * 3) / 2; // Two columns

        // Only include selected stops in export
        const stopsToExport = selectedStops;

        // Category colors for PDF
        const categoryColors = {
          water: { bg: [219, 234, 254], text: [30, 64, 175] },
          camp: { bg: [220, 252, 231], text: [21, 128, 61] },
          food: { bg: [254, 243, 199], text: [180, 83, 9] },
          store: { bg: [243, 232, 255], text: [126, 34, 206] },
          scenic: { bg: [254, 226, 226], text: [185, 28, 28] }
        };

        const categoryIcons = {
          water: 'üíß',
          camp: '‚õ∫',
          food: 'üç¥',
          store: 'üè™',
          scenic: 'üì∏'
        };

        // --- HEADER ---
        doc.setFillColor(26, 26, 26);
        doc.rect(0, 0, pageWidth, 18, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(14);
        doc.setFont(undefined, 'bold');
        doc.text('RouteScout', margin, 12);
        doc.setFontSize(9);
        doc.setFont(undefined, 'normal');
        doc.text('Trip Plan', pageWidth - margin - 20, 12);

        // --- LEFT COLUMN: Route Details ---
        let leftY = 26;

        // Route name
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(14);
        doc.setFont(undefined, 'bold');
        const routeNameLines = doc.splitTextToSize(routeData.name, colWidth);
        doc.text(routeNameLines, margin, leftY);
        leftY += routeNameLines.length * 5 + 4;

        // Stats box
        doc.setFillColor(249, 250, 251);
        doc.roundedRect(margin, leftY, colWidth, 32, 2, 2, 'F');

        doc.setFontSize(8);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(107, 114, 128);

        const statsY = leftY + 6;
        doc.text('Distance', margin + 4, statsY);
        doc.text('Elevation', margin + 4, statsY + 8);
        doc.text('Start', margin + 4, statsY + 16);
        doc.text('Est. Finish', margin + 4, statsY + 24);

        doc.setTextColor(0, 0, 0);
        doc.setFont(undefined, 'bold');
        doc.text(formatDistance(routeData.distance), margin + 28, statsY);
        doc.text(formatElevation(routeData.elevation), margin + 28, statsY + 8);
        doc.text(`${formatDate(getStartDateTime())} ${formatTime(getStartDateTime())}`, margin + 28, statsY + 16);
        doc.text(formatTime(getEndDateTime()), margin + 28, statsY + 24);

        // Second column of stats
        doc.setFont(undefined, 'normal');
        doc.setTextColor(107, 114, 128);
        doc.text('Avg Speed', margin + colWidth/2 + 4, statsY);
        doc.text('Planned Stops', margin + colWidth/2 + 4, statsY + 8);
        doc.text('Possible Stops', margin + colWidth/2 + 4, statsY + 16);
        doc.text('Stop Time', margin + colWidth/2 + 4, statsY + 24);

        doc.setTextColor(0, 0, 0);
        doc.setFont(undefined, 'bold');
        doc.text(formatSpeed(avgSpeed), margin + colWidth/2 + 32, statsY);
        doc.text(String(plannedStopsCount), margin + colWidth/2 + 32, statsY + 8);
        doc.text(String(possibleStopsCount), margin + colWidth/2 + 32, statsY + 16);
        doc.text(`${totalStopMinutes} min`, margin + colWidth/2 + 32, statsY + 24);

        leftY += 38;

        // --- RIGHT COLUMN: Map & Elevation ---
        const rightX = margin + colWidth + margin;
        let rightY = 26;

        // Capture map
        try {
          const mapEl = document.getElementById('map');
          if (mapEl) {
            const mapCanvas = await html2canvas(mapEl, {
              useCORS: true,
              allowTaint: true,
              scale: 2,
              logging: false
            });
            const mapImgData = mapCanvas.toDataURL('image/jpeg', 0.85);
            const mapHeight = 55;
            doc.addImage(mapImgData, 'JPEG', rightX, rightY, colWidth, mapHeight);
            rightY += mapHeight + 4;
          }
        } catch (e) {
          console.log('Could not capture map:', e);
          rightY += 4;
        }

        // Capture elevation profile
        try {
          const elevEl = document.querySelector('.elevation-profile');
          if (elevEl) {
            const elevCanvas = await html2canvas(elevEl, {
              scale: 2,
              logging: false,
              backgroundColor: '#ffffff'
            });
            const elevImgData = elevCanvas.toDataURL('image/jpeg', 0.85);
            const elevHeight = 28;
            doc.addImage(elevImgData, 'JPEG', rightX, rightY, colWidth, elevHeight);
            rightY += elevHeight + 4;
          }
        } catch (e) {
          console.log('Could not capture elevation:', e);
        }

        // --- SELECTED STOPS (below both columns) ---
        let stopsY = Math.max(leftY, rightY) + 4;

        doc.setFillColor(26, 26, 26);
        doc.rect(margin, stopsY, pageWidth - margin * 2, 7, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(9);
        doc.setFont(undefined, 'bold');
        doc.text(`Selected Stops (${stopsToExport.length})`, margin + 3, stopsY + 5);
        stopsY += 10;

        if (stopsToExport.length === 0) {
          doc.setFontSize(9);
          doc.setTextColor(107, 114, 128);
          doc.setFont(undefined, 'normal');
          doc.text('No stops selected. Mark stops as "Planned" or "Possible" to include them.', margin + 3, stopsY + 4);
        } else {
          // Calculate how many stops can fit
          const stopHeight = 9;
          const availableHeight = pageHeight - stopsY - margin;
          const stopsPerPage = Math.floor(availableHeight / stopHeight);
          const maxFirstPageStops = Math.min(stopsToExport.length, stopsPerPage);

          stopsToExport.forEach((poi, idx) => {
            // Check if we need a new page
            if (stopsY > pageHeight - margin - stopHeight) {
              doc.addPage();
              stopsY = margin;

              // Add header on new page
              doc.setFillColor(26, 26, 26);
              doc.rect(margin, stopsY, pageWidth - margin * 2, 7, 'F');
              doc.setTextColor(255, 255, 255);
              doc.setFontSize(9);
              doc.setFont(undefined, 'bold');
              doc.text(`Selected Stops (continued)`, margin + 3, stopsY + 5);
              stopsY += 10;
            }

            const colors = categoryColors[poi.category] || categoryColors.water;

            // Stop row background
            doc.setFillColor(colors.bg[0], colors.bg[1], colors.bg[2]);
            doc.roundedRect(margin, stopsY, pageWidth - margin * 2, stopHeight - 1, 1, 1, 'F');

            // Category icon (emoji approximation - use first letter)
            doc.setFontSize(7);
            doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            const icon = categoryIcons[poi.category] || 'üìç';
            doc.text(icon, margin + 2, stopsY + 5.5);

            // Time
            doc.setFontSize(8);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(0, 0, 0);
            doc.text(formatTime(poi.eta), margin + 10, stopsY + 5.5);

            // Name
            doc.setFont(undefined, 'normal');
            const nameMaxWidth = 50;
            let displayName = poi.name;
            if (doc.getTextWidth(displayName) > nameMaxWidth) {
              while (doc.getTextWidth(displayName + '...') > nameMaxWidth && displayName.length > 0) {
                displayName = displayName.slice(0, -1);
              }
              displayName += '...';
            }
            doc.text(displayName, margin + 26, stopsY + 5.5);

            // Type badge
            doc.setFontSize(7);
            doc.setTextColor(colors.text[0], colors.text[1], colors.text[2]);
            doc.text(poi.type, margin + 80, stopsY + 5.5);

            // Distance
            doc.setTextColor(107, 114, 128);
            doc.text(formatDistance(poi.distanceKm), margin + 115, stopsY + 5.5);

            // Detour
            doc.text(formatDetour(poi.distanceOffRoute), margin + 135, stopsY + 5.5);

            // Stop type & time
            if (poi.isPlannedStop) {
              doc.setFillColor(251, 191, 36);
              doc.roundedRect(margin + 155, stopsY + 1.5, 18, 5, 1, 1, 'F');
              doc.setTextColor(0, 0, 0);
              doc.setFontSize(6);
              doc.text(`${poi.stopMinutes}min`, margin + 156, stopsY + 5);
            } else if (poi.isPossibleStop) {
              doc.setFillColor(191, 219, 254);
              doc.roundedRect(margin + 155, stopsY + 1.5, 18, 5, 1, 1, 'F');
              doc.setTextColor(30, 64, 175);
              doc.setFontSize(6);
              doc.text('possible', margin + 156, stopsY + 5);
            }

            // Hours info
            if (poi.hoursInfo?.display) {
              doc.setFontSize(6);
              if (poi.hoursInfo.isOpen === true) {
                doc.setTextColor(5, 150, 105);
              } else if (poi.hoursInfo.isOpen === false) {
                doc.setTextColor(220, 38, 38);
              } else {
                doc.setTextColor(107, 114, 128);
              }
              const hoursText = poi.hoursInfo.display.length > 12
                ? poi.hoursInfo.display.substring(0, 12) + '...'
                : poi.hoursInfo.display;
              doc.text(hoursText, margin + 175, stopsY + 5.5);
            }

            stopsY += stopHeight;
          });
        }

        // Footer on last page
        doc.setFontSize(7);
        doc.setTextColor(156, 163, 175);
        doc.text('Generated by RouteScout ‚Ä¢ routescout.app', margin, pageHeight - 6);

        doc.save(`${routeData.name.replace(/[^a-z0-9]/gi, '-')}-trip-plan.pdf`);
        setShowExport(false);
      };

      const resetApp = () => {
        setRouteData(null);
        setPois([]);
        setPlannedStops({});
        setPossibleStops({});
        setError(null);
        setRouteUrl('');
      };

      // Get display speed label
      const speedLabel = useMiles
        ? `${kmToMi(avgSpeed).toFixed(1)} mph`
        : `${avgSpeed} km/h`;

      // Get expanded POI for popover
      const expandedPoi = expandedStopId ? enrichedPOIs.find(p => p.id === expandedStopId) : null;

      // POI Popover component for condensed views
      const renderPoiPopover = () => {
        if (!expandedPoi) return null;

        const cat = POI_CATEGORIES[expandedPoi.category];
        const iconHtml = expandedPoi.category === 'water' ? 'üíß' :
                        expandedPoi.category === 'camp' ? '‚õ∫' :
                        expandedPoi.category === 'food' ? 'üç¥' :
                        expandedPoi.category === 'store' ? 'üè™' : 'üì∏';
        const distLabel = useMiles
          ? `Mile ${kmToMi(expandedPoi.distanceKm).toFixed(1)}`
          : `Km ${expandedPoi.distanceKm.toFixed(1)}`;
        const osmUrl = `https://www.openstreetmap.org/${expandedPoi.osmType}/${expandedPoi.osmId}`;
        const gmapsUrl = `https://www.google.com/maps/search/?api=1&query=${expandedPoi.coordinates[0]},${expandedPoi.coordinates[1]}`;

        return (
          <div className="poi-popover-overlay" onClick={() => setExpandedStopId(null)}>
            <div className="poi-popover" onClick={e => e.stopPropagation()}>
              <div className="poi-popover-header">
                <div className="poi-popover-title">
                  <span>{iconHtml}</span>
                  {expandedPoi.name}
                </div>
                <button className="poi-popover-close" onClick={() => setExpandedStopId(null)}>√ó</button>
              </div>
              <div className="poi-popover-body">
                <div className="poi-popover-meta">
                  <div className="poi-popover-meta-item">
                    <span>üè∑Ô∏è</span>
                    <span>{expandedPoi.type}</span>
                  </div>
                  <div className="poi-popover-meta-item">
                    <span>üïê</span>
                    <span>ETA: {formatTime(expandedPoi.eta)}</span>
                  </div>
                  <div className="poi-popover-meta-item">
                    <span>üìç</span>
                    <span>{distLabel}</span>
                  </div>
                  <div className="poi-popover-meta-item">
                    <span>‚ÜóÔ∏è</span>
                    <span>{expandedPoi.distanceOffRoute < 50 ? <span className="on-route-badge">On Route</span> : formatDetour(expandedPoi.distanceOffRoute)}</span>
                  </div>
                  {expandedPoi.location && (
                    <div className="poi-popover-meta-item">
                      <span>üó∫Ô∏è</span>
                      <span>{expandedPoi.location}</span>
                    </div>
                  )}
                  {expandedPoi.hoursInfo?.display && (
                    <div className="poi-popover-meta-item">
                      <span>üïê</span>
                      <span>
                        <span className={`hours-badge ${expandedPoi.hoursInfo.isOpen === true ? 'open' : expandedPoi.hoursInfo.isOpen === false ? 'closed' : 'unknown'}`}>
                          {expandedPoi.hoursInfo.isOpen === true ? '‚úì Open' : expandedPoi.hoursInfo.isOpen === false ? '‚úó Closed' : '‚è∞ Unknown'}
                        </span>
                        <span className="hours-display">Hours: {expandedPoi.hoursInfo.display}</span>
                      </span>
                    </div>
                  )}
                </div>

                <div className="poi-popover-actions">
                  {!expandedPoi.isPlannedStop && !expandedPoi.isPossibleStop && (
                    <>
                      <button
                        className="btn-planned"
                        onClick={() => {
                          setPlannedStops(prev => ({ ...prev, [expandedPoi.id]: 15 }));
                          setExpandedStopId(null);
                        }}
                      >
                        + Planned Stop
                      </button>
                      <button
                        className="btn-possible"
                        onClick={() => {
                          setPossibleStops(prev => ({ ...prev, [expandedPoi.id]: true }));
                          setExpandedStopId(null);
                        }}
                      >
                        + Possible
                      </button>
                    </>
                  )}
                  {expandedPoi.isPlannedStop && (
                    <button
                      className="btn-remove"
                      onClick={() => {
                        setPlannedStops(prev => {
                          const next = { ...prev };
                          delete next[expandedPoi.id];
                          return next;
                        });
                        setExpandedStopId(null);
                      }}
                    >
                      Remove Planned Stop
                    </button>
                  )}
                  {expandedPoi.isPossibleStop && (
                    <>
                      <button
                        className="btn-planned"
                        onClick={() => {
                          setPossibleStops(prev => {
                            const next = { ...prev };
                            delete next[expandedPoi.id];
                            return next;
                          });
                          setPlannedStops(prev => ({ ...prev, [expandedPoi.id]: 15 }));
                          setExpandedStopId(null);
                        }}
                      >
                        Convert to Planned
                      </button>
                      <button
                        className="btn-remove"
                        onClick={() => {
                          setPossibleStops(prev => {
                            const next = { ...prev };
                            delete next[expandedPoi.id];
                            return next;
                          });
                          setExpandedStopId(null);
                        }}
                      >
                        Remove
                      </button>
                    </>
                  )}
                </div>

                <div className="poi-popover-links">
                  <a href={osmUrl} target="_blank" rel="noopener noreferrer">
                    OSM ‚Üó
                  </a>
                  <a href={gmapsUrl} target="_blank" rel="noopener noreferrer">
                    Google Maps ‚Üó
                  </a>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Handle selecting a featured route
      const handleSelectFeaturedRoute = async (route) => {
        setSelectedFeaturedRoute(route);
        setCurrentView('planner');

        // If the route has a GPX URL, automatically load it
        if (route.gpxUrl) {
          await loadFeaturedRouteGpx(route);
        }
      };

      // Load GPX for a featured route from URL
      const loadFeaturedRouteGpx = async (route) => {
        if (!route.gpxUrl) {
          console.log('No GPX URL for route:', route.name);
          return;
        }

        if (searchCategories.length === 0) {
          setError('Please select at least one resource type to search.');
          return;
        }

        setError(null);
        setIsLoading(true);
        setLoadingProgress(0);
        setPlannedStops({});
        setPossibleStops({});
        setRouteData(null);
        setPois([]);

        const categoryLabels = searchCategories.map(c => POI_CATEGORIES[c]?.label).filter(Boolean).join(', ');

        setLoadingSteps([
          { id: 'fetch', label: 'Downloading route', detail: route.gpxUrl, status: 'active' },
          { id: 'parse', label: 'Parsing GPX file', detail: `${route.distance} miles of track data`, status: 'pending' },
          { id: 'pois', label: 'Querying OpenStreetMap', detail: `Searching: ${categoryLabels}`, status: 'pending' },
          { id: 'process', label: 'Processing results', detail: 'Calculating distances and filtering', status: 'pending' }
        ]);
        setLoadingStep(`Connecting to server...`);
        setLoadingProgress(5);

        try {
          // Fetch GPX from URL
          const gpxText = await fetchGpxFromUrl(route.gpxUrl);
          setLoadingProgress(20);

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'fetch' ? { ...s, status: 'done', label: 'Route downloaded', detail: `${(gpxText.length / 1024).toFixed(0)} KB received` } :
            s.id === 'parse' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Extracting track points...');

          // Allow UI to update
          await new Promise(resolve => setTimeout(resolve, 50));

          const parsedRoute = parseGPX(gpxText);
          setLoadingProgress(30);

          if (parsedRoute.coordinates.length < 2) {
            throw new Error('GPX file contains no valid track points');
          }

          const routeInfo = `${parsedRoute.distance.toFixed(0)}km ‚Ä¢ ${parsedRoute.totalPoints || parsedRoute.coordinates.length} points`;
          console.log(`Parsed: ${routeInfo}`);

          setRouteData(parsedRoute);

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'parse' ? { ...s, status: 'done', label: 'GPX parsed successfully', detail: routeInfo } :
            s.id === 'pois' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Connecting to OpenStreetMap...');
          setLoadingProgress(35);

          // Allow UI to update before POI fetch
          await new Promise(resolve => setTimeout(resolve, 50));

          let rawPois = [];
          let segmentCount = 1;
          try {
            rawPois = await fetchPOIs(parsedRoute.coordinates, (msg) => {
              setLoadingStep(msg);
              // Handle segment progress for batch queries
              if (msg.includes('Processing') && msg.includes('segments')) {
                const match = msg.match(/(\d+) route segments/);
                if (match) segmentCount = parseInt(match[1]);
                setLoadingProgress(40);
                setLoadingSteps(prev => prev.map(s =>
                  s.id === 'pois' ? { ...s, detail: `Batch query: ${segmentCount} segments` } : s
                ));
              } else if (msg.includes('Segment') && msg.includes('complete')) {
                const match = msg.match(/Segment (\d+)\/(\d+)/);
                if (match) {
                  const current = parseInt(match[1]);
                  const total = parseInt(match[2]);
                  const progress = 40 + (current / total) * 35; // 40-75%
                  setLoadingProgress(Math.round(progress));
                }
              } else if (msg.includes('Querying')) {
                setLoadingProgress(45);
              } else if (msg.includes('Processing POI')) {
                setLoadingProgress(75);
              }
            }, searchCategories);
          } catch (poiErr) {
            console.error('POI fetch error:', poiErr);
            setError('Could not fetch POIs from OpenStreetMap. The route is loaded - you can try refreshing to fetch POIs again.');
          }

          setLoadingProgress(85);

          // Handle 0 POIs case
          if (rawPois.length === 0) {
            setError(
              `No resources found along ${route.name}. This may happen if OpenStreetMap servers were busy. Try clicking "Re-scan Route" to try again.`
            );
          }

          setLoadingSteps(prev => prev.map(s =>
            s.id === 'pois' ? { ...s, status: 'done', label: 'Resources found', detail: `${rawPois.length} locations${segmentCount > 1 ? ` (${segmentCount} segments)` : ''}` } :
            s.id === 'process' ? { ...s, status: 'active' } : s
          ));
          setLoadingStep('Calculating distances from route...');

          setPois(rawPois);
          setActiveFilters([...searchCategories]);
          setLoadingProgress(95);

          setLoadingStep('Saving to history...');
          const updatedHistory = saveToHistory(parsedRoute, rawPois);
          setHistory(updatedHistory);

          setLoadingSteps(prev => prev.map(s => ({ ...s, status: 'done' })));
          setLoadingProgress(100);

        } catch (err) {
          console.error('Featured route loading error:', err);
          setError(err.message || `Failed to load ${route.name} route`);
        } finally {
          setIsLoading(false);
          setLoadingProgress(0);
        }
      };

      // Go back to homepage
      const goToHomepage = () => {
        setCurrentView('home');
        setSelectedFeaturedRoute(null);
        resetApp();
      };

      // Homepage View
      if (currentView === 'home') {
        return (
          <div>
            <header>
              <div className="container header-content">
                <div className="logo">
                  <Icons.Bike />
                  RouteScout
                </div>
                <div className="header-actions">
                  <div className="unit-toggle">
                    <button
                      className={useMiles ? 'active' : ''}
                      onClick={() => setUseMiles(true)}
                    >
                      Miles
                    </button>
                    <button
                      className={!useMiles ? 'active' : ''}
                      onClick={() => setUseMiles(false)}
                    >
                      Km
                    </button>
                  </div>
                </div>
              </div>
            </header>

            <section className="homepage">
              <div className="container">
                <div className="homepage-hero">
                  <h1>Scout Your Next Adventure</h1>
                  <p>
                    Discover water sources, camping spots, food stops, and resupply points along your cycling route.
                    Built for ultra-distance and bikepacking adventures.
                  </p>
                </div>

                <div className="featured-routes">
                  <h2>Featured Routes</h2>
                  <div className="featured-grid">
                    {FEATURED_ROUTES.map(route => (
                      <div
                        key={route.id}
                        className="featured-card"
                        onClick={() => handleSelectFeaturedRoute(route)}
                      >
                        <div
                          className="featured-card-image"
                          style={{
                            backgroundImage: `url(${route.image})`,
                            backgroundColor: route.color
                          }}
                        >
                          <span className="featured-card-badge">{route.badge}</span>
                        </div>
                        <div className="featured-card-content">
                          <h3 className="featured-card-title">{route.name}</h3>
                          <div className="featured-card-stats">
                            <div className="featured-card-stat">
                              <Icons.Route />
                              <strong>{route.distance}</strong> {useMiles ? 'mi' : 'km'}
                            </div>
                            <div className="featured-card-stat">
                              <Icons.Mountain />
                              <strong>{(route.elevation / 1000).toFixed(0)}k</strong> ft gain
                            </div>
                            <div className="featured-card-stat">
                              <Icons.MapPin />
                              {route.location}
                            </div>
                          </div>
                          <p className="featured-card-desc">{route.description}</p>
                          <div className="featured-card-footer">
                            {route.gpxUrl ? (
                              <span className="featured-card-gpx-badge available">
                                <Icons.Check /> Official Route Ready
                              </span>
                            ) : route.hasGpx ? (
                              <span className="featured-card-gpx-badge pending">
                                <Icons.Upload /> GPX Available
                              </span>
                            ) : null}
                            <span className="featured-card-btn">
                              Scout This Route
                              <Icons.ChevronRight />
                            </span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="upload-section">
                  <h3>Have Your Own Route?</h3>
                  <p>Upload a GPX file to discover resources along any cycling route.</p>
                  <button
                    className="btn btn-primary"
                    onClick={() => setCurrentView('planner')}
                  >
                    <Icons.Upload />
                    Upload GPX File
                  </button>
                </div>

                <div className="powered-by">
                  <span>A tool by </span>
                  <a href="https://www.midwestultracycling.com" target="_blank" rel="noopener noreferrer">
                    Midwest Ultra Cycling
                  </a>
                </div>
              </div>
            </section>
          </div>
        );
      }

      // Planner View
      return (
        <div>
          <header>
            <div className="container header-content">
              <div className="logo" style={{ cursor: 'pointer' }} onClick={goToHomepage}>
                <Icons.Bike />
                RouteScout
              </div>
              <div className="header-actions">
                <div className="unit-toggle">
                  <button
                    className={useMiles ? 'active' : ''}
                    onClick={() => setUseMiles(true)}
                  >
                    Miles
                  </button>
                  <button
                    className={!useMiles ? 'active' : ''}
                    onClick={() => setUseMiles(false)}
                  >
                    Km
                  </button>
                </div>
                {routeData && (
                  <button className="btn btn-outline btn-sm" onClick={resetApp}>
                    New Route
                  </button>
                )}
                <button className="btn btn-secondary btn-sm" onClick={goToHomepage}>
                  ‚Üê Home
                </button>
              </div>
            </div>
          </header>

          {isLoading && (
            <div className="loading-overlay">
              <div className="loading-card">
                <div className="loading-header">
                  <div className="spinner"></div>
                  <div>
                    <div className="loading-title">
                      {selectedFeaturedRoute ? `Scouting ${selectedFeaturedRoute.name}` : 'Analyzing Your Route'}
                    </div>
                    <div className="loading-subtitle">{loadingStep || 'Please wait...'}</div>
                  </div>
                </div>

                <div className="progress-container">
                  <div className="progress-bar-bg">
                    <div className="progress-bar-fill" style={{ width: `${loadingProgress}%` }}></div>
                  </div>
                  <div className="progress-text">
                    <span>{loadingSteps.filter(s => s.status === 'done').length} of {loadingSteps.length} steps</span>
                    <span>{loadingProgress}%</span>
                  </div>
                </div>

                <div className="loading-steps">
                  {loadingSteps.map(step => (
                    <div key={step.id} className={`loading-step ${step.status}`}>
                      <span className="loading-step-icon">
                        {step.status === 'done' ? '‚úì' : step.status === 'active' ? '‚óâ' : '‚óã'}
                      </span>
                      <div className="loading-step-content">
                        <div className="loading-step-label">{step.label}</div>
                        {step.detail && <div className="loading-step-detail">{step.detail}</div>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}

          {!routeData && (
            <section className="input-section">
              <div className="container">
                {selectedFeaturedRoute && (
                  <div className="route-info" style={{ marginBottom: '24px', background: '#E8F0F8', borderColor: 'var(--color-primary)' }}>
                    <div className="route-info-header">
                      <span className="route-info-icon">üö¥</span>
                      <h3 style={{ color: 'var(--color-primary)' }}>Scouting: {selectedFeaturedRoute.name}</h3>
                    </div>
                    <p style={{ color: 'var(--color-primary)' }}>
                      {selectedFeaturedRoute.distance} miles ‚Ä¢ {(selectedFeaturedRoute.elevation / 1000).toFixed(0)}k ft elevation ‚Ä¢ {selectedFeaturedRoute.location}
                    </p>
                  </div>
                )}
                <div className="card" style={{ padding: '32px' }}>
                  <h2 style={{ marginBottom: '8px', fontSize: '24px', color: 'var(--color-text)' }}>
                    {selectedFeaturedRoute ? `Configure Your ${selectedFeaturedRoute.name} Scout` : 'Plan Your Adventure'}
                  </h2>
                  <p style={{ color: 'var(--color-text-muted)', marginBottom: '24px' }}>
                    {selectedFeaturedRoute
                      ? 'Set your start date and pace, then upload the official GPX to discover resources along the route.'
                      : 'Upload a GPX file to discover water, camping, food, and more along your route.'
                    }
                  </p>

                  {error && (
                    <div className="alert alert-warning">
                      <span className="alert-icon">‚ö†Ô∏è</span>
                      <div className="alert-content">
                        <div className="alert-text">{error}</div>
                      </div>
                    </div>
                  )}

                  <div className="settings-row">
                    <div className="form-group" style={{ marginBottom: 0 }}>
                      <label>Start Date</label>
                      <input
                        type="date"
                        value={startDate}
                        onChange={(e) => setStartDate(e.target.value)}
                      />
                    </div>
                    <div className="form-group" style={{ marginBottom: 0 }}>
                      <label>Start Time</label>
                      <input
                        type="time"
                        value={startTime}
                        onChange={(e) => setStartTime(e.target.value)}
                      />
                    </div>
                    <div className="form-group" style={{ marginBottom: 0 }}>
                      <label>Average Speed</label>
                      <div className="speed-input-group">
                        <input
                          type="number"
                          min={useMiles ? 3 : 5}
                          max={useMiles ? 25 : 40}
                          step="0.5"
                          value={useMiles ? kmToMi(avgSpeed).toFixed(1) : avgSpeed}
                          onChange={(e) => {
                            const val = parseFloat(e.target.value) || (useMiles ? 10 : 16);
                            setAvgSpeed(useMiles ? miToKm(val) : val);
                          }}
                        />
                        <span>{useMiles ? 'mph' : 'km/h'}</span>
                      </div>
                    </div>
                    <div className="form-group" style={{ marginBottom: 0 }}>
                      <label>Max Detour</label>
                      <select
                        value={maxDetourDistance}
                        onChange={(e) => setMaxDetourDistance(Number(e.target.value))}
                      >
                        <option value={500}>{useMiles ? '~0.3 mi' : '500 m'}</option>
                        <option value={1000}>{useMiles ? '~0.6 mi' : '1 km'}</option>
                        <option value={1500}>{useMiles ? '~1 mi' : '1.5 km'}</option>
                        <option value={3000}>{useMiles ? '~2 mi' : '3 km'}</option>
                        <option value={5000}>{useMiles ? '~3 mi' : '5 km'}</option>
                        <option value={10000}>{useMiles ? '~6 mi' : '10 km'}</option>
                        <option value={99999}>Show all</option>
                      </select>
                    </div>
                  </div>

                  <div className="search-categories" style={{ marginTop: '20px' }}>
                    <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500', color: '#374151' }}>
                      Resources to Search
                    </label>
                    <div className="filter-pills" style={{ marginTop: '0' }}>
                      {Object.entries(POI_CATEGORIES).map(([key, cat]) => (
                        <button
                          key={key}
                          className={`pill ${searchCategories.includes(key) ? 'active' : ''}`}
                          onClick={() => {
                            setSearchCategories(prev =>
                              prev.includes(key)
                                ? prev.filter(k => k !== key)
                                : [...prev, key]
                            );
                          }}
                        >
                          <cat.icon />
                          {cat.label}
                        </button>
                      ))}
                    </div>
                    {searchCategories.length === 0 && (
                      <p style={{ fontSize: '13px', color: '#dc2626', marginTop: '8px' }}>
                        Select at least one resource type to search.
                      </p>
                    )}
                  </div>

                  {/* Official Route Load Button for Featured Routes */}
                  {selectedFeaturedRoute && selectedFeaturedRoute.gpxUrl && (
                    <div style={{ marginTop: '24px', marginBottom: '16px' }}>
                      <button
                        className="btn btn-primary"
                        onClick={() => loadFeaturedRouteGpx(selectedFeaturedRoute)}
                        disabled={isLoading}
                        style={{
                          width: '100%',
                          padding: '16px 24px',
                          fontSize: '16px',
                          fontWeight: '600',
                          background: 'var(--color-primary)',
                          borderRadius: '12px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '10px'
                        }}
                      >
                        <Icons.Route />
                        {isLoading ? 'Loading Route...' : `Load Official ${selectedFeaturedRoute.name} Route`}
                      </button>
                      <p style={{ fontSize: '13px', color: 'var(--color-text-muted)', marginTop: '12px', textAlign: 'center' }}>
                        Or upload your own GPX file below to scout a different route
                      </p>
                    </div>
                  )}

                  {/* Notice for Featured Routes without hosted GPX */}
                  {selectedFeaturedRoute && !selectedFeaturedRoute.gpxUrl && selectedFeaturedRoute.hasGpx && (
                    <div className="alert" style={{ marginTop: '24px', marginBottom: '16px', background: '#EEF5FF', borderColor: 'var(--color-primary)' }}>
                      <span className="alert-icon">üìã</span>
                      <div className="alert-content">
                        <div className="alert-text" style={{ color: 'var(--color-primary)' }}>
                          <strong>Upload the official {selectedFeaturedRoute.name} GPX</strong><br/>
                          Download the official route from the race website, then upload it below to scout resources.
                        </div>
                      </div>
                    </div>
                  )}

                  <div className="input-tabs" style={{ marginTop: selectedFeaturedRoute ? '0' : '24px' }}>
                    <button
                      className={`input-tab ${inputMode === 'file' ? 'active' : ''}`}
                      onClick={() => setInputMode('file')}
                    >
                      <Icons.Upload /> Upload GPX
                    </button>
                    <button
                      className={`input-tab ${inputMode === 'url' ? 'active' : ''}`}
                      onClick={() => setInputMode('url')}
                    >
                      <Icons.Link /> Paste URL
                    </button>
                    {history.length > 0 && (
                      <button
                        className={`input-tab ${inputMode === 'history' ? 'active' : ''}`}
                        onClick={() => setInputMode('history')}
                      >
                        <Icons.History /> Recent
                      </button>
                    )}
                  </div>

                  {inputMode === 'file' && (
                    <div
                      className={`file-drop ${dragOver ? 'dragover' : ''}`}
                      onDragOver={handleDragOver}
                      onDragLeave={handleDragLeave}
                      onDrop={handleDrop}
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <div className="file-drop-icon">üìÅ</div>
                      <h3>Drop your GPX file here</h3>
                      <p>or click to browse</p>
                      <input
                        ref={fileInputRef}
                        type="file"
                        accept=".gpx,application/gpx+xml"
                        onChange={(e) => handleFile(e.target.files[0])}
                      />
                    </div>
                  )}

                  {inputMode === 'url' && (
                    <div>
                      <div className="form-group">
                        <label>Route URL</label>
                        <div className="url-input-group">
                          <input
                            type="url"
                            placeholder="https://ridewithgps.com/routes/... or strava.com/routes/..."
                            value={routeUrl}
                            onChange={(e) => setRouteUrl(e.target.value)}
                          />
                          <button className="btn btn-primary" onClick={handleUrlSubmit}>
                            Load
                          </button>
                        </div>
                      </div>
                      <p style={{ fontSize: '13px', color: '#6b7280', marginTop: '8px' }}>
                        Tip: Export your route as a GPX file from RideWithGPS or Strava and upload it directly.
                      </p>
                    </div>
                  )}

                  {inputMode === 'history' && (
                    <div className="history-list">
                      {history.map(entry => (
                        <div
                          key={entry.id}
                          className="history-item"
                          onClick={() => loadFromHistory(entry)}
                        >
                          <div className="history-item-info">
                            <div className="history-item-name">{entry.name}</div>
                            <div className="history-item-meta">
                              {formatDistance(entry.distance)} ‚Ä¢ {entry.poiCount} resources ‚Ä¢
                              {' '}{new Date(entry.date).toLocaleDateString()}
                            </div>
                          </div>
                          <div className="history-item-actions">
                            <button
                              className="history-delete"
                              onClick={(e) => handleDeleteHistory(e, entry.id)}
                              title="Delete"
                            >
                              <Icons.Trash />
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </section>
          )}

          {routeData && (
            <section className="results-section">
              <div className="container">
                <div className="route-info">
                  <div className="route-info-header">
                    <span className="route-info-icon">üö¥</span>
                    <h3>{routeData.name}</h3>
                  </div>
                  <p>{formatDate(getStartDateTime())} ‚Ä¢ Starting {formatTime(getStartDateTime())}</p>
                </div>

                <div className="stats-bar">
                  <div className="card stat-card">
                    <div className="stat-value">{getDisplayDistance(routeData.distance)}</div>
                    <div className="stat-label">{useMiles ? 'Miles' : 'Kilometers'}</div>
                  </div>
                  <div className="card stat-card">
                    <div className="stat-value">{getDisplayElevation(routeData.elevation)}</div>
                    <div className="stat-label">{useMiles ? 'Ft' : 'M'} Climbing</div>
                  </div>
                  <div className="card stat-card">
                    <div className="stat-value">{(routeData.distance / avgSpeed).toFixed(1)}</div>
                    <div className="stat-label">Ride Time (h)</div>
                  </div>
                  <div className={`card stat-card ${totalStopMinutes > 0 ? 'highlight' : ''}`}>
                    <div className="stat-value">{totalStopMinutes}</div>
                    <div className="stat-label">Stop Time (min)</div>
                  </div>
                  <div className="card stat-card">
                    <div className="stat-value">{formatTime(getEndDateTime())}</div>
                    <div className="stat-label">Est. Finish</div>
                  </div>
                  <div className="card stat-card">
                    <div className="stat-value">{enrichedPOIs.length}</div>
                    <div className="stat-label">Resources</div>
                  </div>
                </div>

                {totalSelectedCount > 0 && (
                  <div ref={plannedStopsSectionRef} className="planned-stops-summary">
                    <div className="planned-stops-summary-text">
                      {plannedStopsCount > 0 && (
                        <><strong>{plannedStopsCount}</strong> planned stop{plannedStopsCount !== 1 ? 's' : ''} ({totalStopMinutes} min)</>
                      )}
                      {plannedStopsCount > 0 && possibleStopsCount > 0 && ' ‚Ä¢ '}
                      {possibleStopsCount > 0 && (
                        <><strong>{possibleStopsCount}</strong> possible stop{possibleStopsCount !== 1 ? 's' : ''}</>
                      )}
                    </div>
                    <button
                      className="btn btn-xs btn-outline"
                      onClick={() => { setPlannedStops({}); setPossibleStops({}); }}
                    >
                      Clear all
                    </button>
                  </div>
                )}

                {selectedStops.length > 0 && (
                  <div className="selected-stops-summary">
                    <h4>Selected Stops ({selectedStops.length})</h4>
                    {selectedStops.map(poi => (
                      <div key={poi.id} className={`selected-stop-item ${poi.isPlannedStop ? 'planned' : 'possible'}`}>
                        <div className="selected-stop-info">
                          <span style={{ fontSize: '14px' }}>
                            {poi.category === 'water' ? 'üíß' : poi.category === 'camp' ? '‚õ∫' : poi.category === 'food' ? 'üç¥' : poi.category === 'store' ? 'üè™' : 'üì∏'}
                          </span>
                          <div className="selected-stop-details">
                            <span className="selected-stop-name" title={poi.name}>{poi.name}</span>
                            <span className="selected-stop-meta">
                              {formatTime(poi.eta)} ‚Ä¢ {formatDistance(poi.distanceKm)} ‚Ä¢ {formatDetour(poi.distanceOffRoute)}
                            </span>
                            {poi.hoursInfo?.display && (
                              <span className="selected-stop-hours">
                                <span className={poi.hoursInfo.isOpen === true ? 'open' : poi.hoursInfo.isOpen === false ? 'closed' : ''}>
                                  {poi.hoursInfo.isOpen === true ? '‚úì Open' : poi.hoursInfo.isOpen === false ? '‚úó Closed' : '‚è∞'}
                                </span>
                                {' ¬∑ Hours: '}{poi.hoursInfo.display}
                              </span>
                            )}
                          </div>
                        </div>
                        <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                          {poi.isPlannedStop ? (
                            <div className="stop-time-editor">
                              <button
                                className="time-adjust-btn"
                                onClick={() => setPlannedStops(prev => ({
                                  ...prev,
                                  [poi.id]: Math.max(5, (prev[poi.id] || 15) - 5)
                                }))}
                              >‚àí</button>
                              <span className="stop-time-value">{poi.stopMinutes}m</span>
                              <button
                                className="time-adjust-btn"
                                onClick={() => setPlannedStops(prev => ({
                                  ...prev,
                                  [poi.id]: Math.min(480, (prev[poi.id] || 15) + 5)
                                }))}
                              >+</button>
                            </div>
                          ) : (
                            <button
                              className="btn btn-xs"
                              style={{ padding: '2px 6px', fontSize: '10px' }}
                              onClick={() => convertToPlanedStop(poi.id)}
                              title="Convert to planned stop"
                            >
                              + Time
                            </button>
                          )}
                          <button
                            className="selected-stop-remove"
                            onClick={() => removeSelectedStop(poi.id)}
                            title="Remove from selection"
                          >
                            ‚úï
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}

                <div ref={mapSectionRef} className="card" style={{ borderRadius: '12px 12px 0 0' }}>
                  <div className="map-container" style={{ borderRadius: '12px 12px 0 0' }}>
                    <div id="map" ref={mapRef}></div>
                    <div className="map-legend">
                      {Object.entries(POI_CATEGORIES).map(([key, cat]) => (
                        <div key={key} className="legend-item">
                          <div className="legend-dot" style={{ background: cat.bgColor, border: `2px solid ${cat.color}` }}></div>
                          <span>{cat.label} ({poiCounts[key]})</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <ElevationProfile
                  routeData={routeData}
                  pois={filteredPOIs}
                  useMiles={useMiles}
                  onPointClick={handleElevationClick}
                />

                <div className="route-controls">
                  <div className="form-group">
                    <label>Start Date</label>
                    <input
                      type="date"
                      value={startDate}
                      onChange={(e) => setStartDate(e.target.value)}
                      style={{ width: '140px' }}
                    />
                  </div>
                  <div className="form-group">
                    <label>Start Time</label>
                    <input
                      type="time"
                      value={startTime}
                      onChange={(e) => setStartTime(e.target.value)}
                      style={{ width: '100px' }}
                    />
                  </div>
                  <div className="form-group">
                    <label>Avg Speed</label>
                    <div className="speed-input-group">
                      <input
                        type="number"
                        min={useMiles ? 3 : 5}
                        max={useMiles ? 25 : 40}
                        step="0.5"
                        value={useMiles ? kmToMi(avgSpeed).toFixed(1) : avgSpeed}
                        onChange={(e) => {
                          const val = parseFloat(e.target.value) || (useMiles ? 10 : 16);
                          setAvgSpeed(useMiles ? miToKm(val) : val);
                        }}
                      />
                      <span>{useMiles ? 'mph' : 'km/h'}</span>
                    </div>
                  </div>
                  <div className="form-group">
                    <label>Max Detour</label>
                    <select
                      value={maxDetourDistance}
                      onChange={(e) => setMaxDetourDistance(Number(e.target.value))}
                      style={{ padding: '8px 10px' }}
                    >
                      <option value={500}>{useMiles ? '~0.3 mi' : '500 m'}</option>
                      <option value={1000}>{useMiles ? '~0.6 mi' : '1 km'}</option>
                      <option value={1500}>{useMiles ? '~1 mi' : '1.5 km'}</option>
                      <option value={3000}>{useMiles ? '~2 mi' : '3 km'}</option>
                      <option value={5000}>{useMiles ? '~3 mi' : '5 km'}</option>
                      <option value={10000}>{useMiles ? '~6 mi' : '10 km'}</option>
                      <option value={99999}>Show all</option>
                    </select>
                  </div>
                  <button
                    className="refresh-btn"
                    onClick={async () => {
                      if (!routeData) return;
                      setIsLoading(true);
                      setLoadingSteps([{ id: 'refresh', label: 'Refreshing resources...', status: 'active' }]);
                      try {
                        const newPois = await fetchPOIs(routeData.coordinates, setLoadingStep, activeFilters);
                        setPois(newPois);
                        setLoadingSteps([{ id: 'refresh', label: `Found ${newPois.length} resources`, status: 'done' }]);
                      } catch (err) {
                        setError('Failed to refresh resources: ' + err.message);
                      } finally {
                        setIsLoading(false);
                      }
                    }}
                    title="Refresh POI data from OpenStreetMap"
                  >
                    üîÑ Refresh
                  </button>
                </div>

                <div className="filter-pills">
                  {Object.entries(POI_CATEGORIES).map(([key, cat]) => (
                    <button
                      key={key}
                      className={`pill ${activeFilters.includes(key) ? 'active' : ''}`}
                      onClick={() => toggleFilter(key)}
                    >
                      <cat.icon />
                      {cat.label}
                      <span className="pill-count">{poiCounts[key]}</span>
                    </button>
                  ))}
                </div>

                <div className="results-header">
                  <div className="results-tabs">
                    <button
                      className={`tab ${activeView === 'timeline' ? 'active' : ''}`}
                      onClick={() => setActiveView('timeline')}
                    >
                      Timeline
                    </button>
                    <button
                      className={`tab ${activeView === 'grid' ? 'active' : ''}`}
                      onClick={() => setActiveView('grid')}
                    >
                      Grid
                    </button>
                  </div>
                  <div className="view-toggle">
                    <button
                      className={viewMode === 'full' ? 'active' : ''}
                      onClick={() => setViewMode('full')}
                    >
                      Full
                    </button>
                    <button
                      className={viewMode === 'condensed' ? 'active' : ''}
                      onClick={() => setViewMode('condensed')}
                    >
                      Condensed
                    </button>
                  </div>
                </div>

                {filteredPOIs.length === 0 && (
                  <div className="empty-state">
                    <h3>No resources found</h3>
                    <p>Try enabling more resource categories using the filters above.</p>
                  </div>
                )}

                {activeView === 'timeline' && filteredPOIs.length > 0 && viewMode === 'full' && (() => {
                  // Build timeline with interleaved mile markers
                  const intervalKm = useMiles ? miToKm(10) : 10;
                  const totalDistKm = routeData.distance;

                  // Create mile markers every 10 miles/km
                  const mileMarkers = [];
                  for (let distKm = intervalKm; distKm < totalDistKm; distKm += intervalKm) {
                    const markerValue = useMiles ? Math.round(kmToMi(distKm)) : Math.round(distKm);
                    mileMarkers.push({ distanceKm: distKm, label: `${markerValue} ${useMiles ? 'mi' : 'km'}` });
                  }

                  // Combine POIs and mile markers, sorted by distance
                  const allItems = [
                    ...filteredPOIs.map(p => ({ type: 'poi', data: p, distanceKm: p.distanceKm })),
                    ...mileMarkers.map(m => ({ type: 'marker', data: m, distanceKm: m.distanceKm }))
                  ].sort((a, b) => a.distanceKm - b.distanceKm);

                  return (
                    <div className="timeline">
                      <div className="timeline-item">
                        <div className="timeline-marker start">‚ñ∂</div>
                        <div className="timeline-content">
                          <div className="timeline-time">{formatTime(getStartDateTime())}</div>
                          <div className="timeline-title">Start</div>
                          <div className="timeline-meta"><span>{useMiles ? 'Mile' : 'Km'} 0</span></div>
                        </div>
                      </div>

                      {allItems.map((item, idx) => {
                        if (item.type === 'marker') {
                          return (
                            <div key={`marker-${idx}`} className="timeline-mile-marker">
                              <div className="timeline-mile-marker-dot"></div>
                              <span className="timeline-mile-marker-label">{item.data.label}</span>
                            </div>
                          );
                        }

                        const poi = item.data;
                        const cat = POI_CATEGORIES[poi.category];
                        const detourClass = poi.distanceOffRoute > 200 ? 'far' : '';
                        const distLabel = useMiles
                          ? `Mile ${kmToMi(poi.distanceKm).toFixed(1)}`
                          : `Km ${poi.distanceKm.toFixed(1)}`;
                        const osmUrl = `https://www.openstreetmap.org/${poi.osmType}/${poi.osmId}`;
                        const gmapsUrl = `https://www.google.com/maps/search/?api=1&query=${poi.coordinates[0]},${poi.coordinates[1]}`;

                        return (
                          <div key={poi.id} className={`timeline-item ${poi.isPlannedStop ? 'planned-stop' : ''}`}>
                            <div className={`timeline-marker ${poi.category}`}>
                              <cat.icon />
                            </div>
                            <div className="timeline-content">
                              <div className="timeline-time">
                                {formatTime(poi.eta)}
                                {poi.isPlannedStop && <span className="planned-stop-badge" style={{ marginLeft: '8px' }}>‚è± {poi.stopMinutes} min stop</span>}
                                {poi.isPossibleStop && <span className="possible-stop-badge" style={{ marginLeft: '8px' }}>üìå Possible</span>}
                              </div>
                              <div className="timeline-title">{poi.name}</div>
                              <div className="timeline-meta">
                                <span>{poi.type}</span>
                                <span>{distLabel}</span>
                                {poi.distanceOffRoute >= 50 ? (
                                  <span className={`detour-badge ${detourClass}`}>
                                    ‚Üó {formatDetour(poi.distanceOffRoute)}
                                  </span>
                                ) : (
                                  <span className="on-route-badge">On Route</span>
                                )}
                                {poi.location && (
                                  <span className="location-text">üìç {poi.location}</span>
                                )}
                              </div>
                              {poi.hoursInfo?.display && (
                                <div style={{ marginTop: '4px', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                  <span className={`hours-badge ${poi.hoursInfo.isOpen === true ? 'open' : poi.hoursInfo.isOpen === false ? 'closed' : 'unknown'}`}>
                                    {poi.hoursInfo.isOpen === true ? '‚úì Open' : poi.hoursInfo.isOpen === false ? '‚úó Closed' : '‚è∞ Unknown'}
                                  </span>
                                  <span className="hours-display">Hours: {poi.hoursInfo.display}</span>
                                </div>
                              )}
                              <div className="timeline-actions">
                                <div className="stop-buttons">
                                  {!poi.isPlannedStop && !poi.isPossibleStop && (
                                    <>
                                      <button
                                        className="stop-btn"
                                        onClick={() => togglePlannedStop(poi.id)}
                                        disabled={plannedStopsCount >= MAX_PLANNED_STOPS}
                                      >
                                        + Planned
                                      </button>
                                      <button
                                        className="stop-btn"
                                        onClick={() => togglePossibleStop(poi.id)}
                                      >
                                        + Possible
                                      </button>
                                    </>
                                  )}
                                  {poi.isPossibleStop && (
                                    <>
                                      <button
                                        className="stop-btn possible"
                                        onClick={() => togglePossibleStop(poi.id)}
                                      >
                                        ‚úì Possible
                                      </button>
                                      <button
                                        className="stop-btn"
                                        onClick={() => convertToPlanedStop(poi.id)}
                                      >
                                        ‚Üí Planned
                                      </button>
                                    </>
                                  )}
                                </div>
                                {poi.isPlannedStop && (
                                  <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                    <div className="stop-time-input">
                                      <input
                                        type="number"
                                        min="5"
                                        max="480"
                                        step="5"
                                        value={poi.stopMinutes}
                                        onChange={(e) => updateStopTime(poi.id, e.target.value)}
                                      />
                                      <span>min</span>
                                    </div>
                                    <button
                                      className="stop-btn planned"
                                      onClick={() => togglePlannedStop(poi.id)}
                                    >
                                      ‚úì Planned
                                    </button>
                                  </div>
                                )}
                                <a
                                  href={osmUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="resource-link"
                                >
                                  OSM <Icons.ExternalLink />
                                </a>
                                <a
                                  href={gmapsUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="resource-link gmaps"
                                >
                                  GMaps <Icons.ExternalLink />
                                </a>
                              </div>
                            </div>
                          </div>
                        );
                      })}

                      <div className="timeline-item">
                        <div className="timeline-marker end">‚óº</div>
                        <div className="timeline-content">
                          <div className="timeline-time">{formatTime(getEndDateTime())}</div>
                          <div className="timeline-title">Finish</div>
                          <div className="timeline-meta">
                            <span>{useMiles ? 'Mile' : 'Km'} {getDisplayDistance(routeData.distance)}</span>
                            {totalStopMinutes > 0 && (
                              <span style={{ color: '#d97706' }}>+{totalStopMinutes} min stops</span>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })()}

                {activeView === 'timeline' && filteredPOIs.length > 0 && viewMode === 'condensed' && (() => {
                  // Group POIs by 10-mile/km intervals
                  const interval = useMiles ? miToKm(10) : 10;
                  const totalDist = routeData.distance;
                  const numSegments = Math.ceil(totalDist / interval);
                  const segments = [];

                  for (let i = 0; i <= numSegments; i++) {
                    const startDist = i * interval;
                    const endDist = (i + 1) * interval;
                    const poisInRange = filteredPOIs.filter(p =>
                      p.distanceKm >= startDist && p.distanceKm < endDist
                    );

                    // Calculate ETA at this mile marker
                    const ridingHours = startDist / avgSpeed;
                    const eta = new Date(getStartDateTime().getTime() + ridingHours * 60 * 60 * 1000);

                    segments.push({
                      mile: useMiles ? Math.round(kmToMi(startDist)) : Math.round(startDist),
                      eta,
                      pois: poisInRange
                    });
                  }

                  return (
                    <div className="condensed-timeline">
                      {segments.map((seg, idx) => (
                        <div key={idx} className="mile-marker-row">
                          <span className="mile-label">
                            {seg.mile} {useMiles ? 'mi' : 'km'}
                          </span>
                          <span className="eta-label">{formatTime(seg.eta)}</span>
                          <div className="stops-in-range">
                            {seg.pois.map(poi => {
                              const cat = POI_CATEGORIES[poi.category];
                              const iconHtml = poi.category === 'water' ? 'üíß' :
                                              poi.category === 'camp' ? '‚õ∫' :
                                              poi.category === 'food' ? 'üç¥' :
                                              poi.category === 'store' ? 'üè™' : 'üì∏';
                              return (
                                <div
                                  key={poi.id}
                                  className={`mini-stop ${poi.isPlannedStop ? 'planned' : ''} ${poi.isPossibleStop ? 'possible' : ''} ${expandedStopId === poi.id ? 'expanded' : ''}`}
                                  onClick={() => setExpandedStopId(expandedStopId === poi.id ? null : poi.id)}
                                  title={`${poi.name} - ${formatTime(poi.eta)}${poi.hoursInfo?.display ? ' - Hours: ' + poi.hoursInfo.display : ''}`}
                                >
                                  <span>{iconHtml}</span>
                                  <span style={{ maxWidth: '80px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                    {poi.name.length > 12 ? poi.name.substring(0, 12) + '...' : poi.name}
                                  </span>
                                  {poi.hoursInfo?.isOpen === false && <span style={{ color: '#dc2626' }}>‚úó</span>}
                                </div>
                              );
                            })}
                            {seg.pois.length === 0 && (
                              <span style={{ color: '#9ca3af', fontSize: '11px', fontStyle: 'italic' }}>No stops in range</span>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  );
                })()}

                {activeView === 'grid' && filteredPOIs.length > 0 && viewMode === 'full' && (
                  <div className="resource-grid">
                    {filteredPOIs.map(poi => {
                      const cat = POI_CATEGORIES[poi.category];
                      const detourClass = poi.distanceOffRoute > 200 ? 'far' : '';
                      const distLabel = useMiles
                        ? `Mile ${kmToMi(poi.distanceKm).toFixed(1)}`
                        : `Km ${poi.distanceKm.toFixed(1)}`;
                      const osmUrl = `https://www.openstreetmap.org/${poi.osmType}/${poi.osmId}`;
                      const gmapsUrl = `https://www.google.com/maps/search/?api=1&query=${poi.coordinates[0]},${poi.coordinates[1]}`;

                      return (
                        <div key={poi.id} className={`card resource-card ${poi.isPlannedStop ? 'planned-stop' : ''} ${poi.isPossibleStop ? 'possible-stop' : ''}`}>
                          <div className="resource-card-header">
                            <div className={`resource-icon ${poi.category}`}>
                              <cat.icon />
                            </div>
                            <div>
                              <div className="resource-name">{poi.name}</div>
                              <div className="resource-type">{poi.type}</div>
                              {poi.location && (
                                <div className="location-text">üìç {poi.location}</div>
                              )}
                            </div>
                          </div>
                          <div className="resource-details">
                            <p>üïê ETA: {formatTime(poi.eta)}</p>
                            {poi.hoursInfo?.display && (
                              <p style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                <span className={`hours-badge ${poi.hoursInfo.isOpen === true ? 'open' : poi.hoursInfo.isOpen === false ? 'closed' : 'unknown'}`}>
                                  {poi.hoursInfo.isOpen === true ? '‚úì Open' : poi.hoursInfo.isOpen === false ? '‚úó Closed' : '‚è∞ Unknown'}
                                </span>
                                <span className="hours-display">Hours: {poi.hoursInfo.display}</span>
                              </p>
                            )}
                            <p>üìç {distLabel}</p>
                            <p>
                              {poi.distanceOffRoute >= 50 ? (
                                <span className={`detour-badge ${detourClass}`}>‚Üó {formatDetour(poi.distanceOffRoute)}</span>
                              ) : (
                                <span className="on-route-badge">On Route</span>
                              )}
                            </p>
                            {poi.isPlannedStop && (
                              <p style={{ color: '#d97706', fontWeight: 600 }}>‚è± Planned stop: {poi.stopMinutes} min</p>
                            )}
                            {poi.isPossibleStop && (
                              <p style={{ color: '#1e40af', fontWeight: 600 }}>üìå Possible stop</p>
                            )}
                          </div>
                          <div className="timeline-actions" style={{ marginTop: '12px' }}>
                            <div className="stop-buttons">
                              {!poi.isPlannedStop && !poi.isPossibleStop && (
                                <>
                                  <button
                                    className="stop-btn"
                                    onClick={() => togglePlannedStop(poi.id)}
                                    disabled={plannedStopsCount >= MAX_PLANNED_STOPS}
                                  >
                                    + Planned
                                  </button>
                                  <button
                                    className="stop-btn"
                                    onClick={() => togglePossibleStop(poi.id)}
                                  >
                                    + Possible
                                  </button>
                                </>
                              )}
                              {poi.isPossibleStop && (
                                <>
                                  <button
                                    className="stop-btn possible"
                                    onClick={() => togglePossibleStop(poi.id)}
                                  >
                                    ‚úì Possible
                                  </button>
                                  <button
                                    className="stop-btn"
                                    onClick={() => convertToPlanedStop(poi.id)}
                                  >
                                    ‚Üí Planned
                                  </button>
                                </>
                              )}
                              {poi.isPlannedStop && (
                                <>
                                  <div className="stop-time-input">
                                    <input
                                      type="number"
                                      min="5"
                                      max="480"
                                      step="5"
                                      value={poi.stopMinutes}
                                      onChange={(e) => updateStopTime(poi.id, e.target.value)}
                                    />
                                    <span>min</span>
                                  </div>
                                  <button
                                    className="stop-btn planned"
                                    onClick={() => togglePlannedStop(poi.id)}
                                  >
                                    ‚úì Planned
                                  </button>
                                </>
                              )}
                            </div>
                          </div>
                          <div style={{ marginTop: '12px' }}>
                            <a
                              href={osmUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="resource-link"
                            >
                              OpenStreetMap <Icons.ExternalLink />
                            </a>
                            <a
                              href={gmapsUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="resource-link gmaps"
                            >
                              Google Maps <Icons.ExternalLink />
                            </a>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}

                {activeView === 'grid' && filteredPOIs.length > 0 && viewMode === 'condensed' && (
                  <div className="condensed-grid">
                    {filteredPOIs.map(poi => {
                      const iconHtml = poi.category === 'water' ? 'üíß' :
                                      poi.category === 'camp' ? '‚õ∫' :
                                      poi.category === 'food' ? 'üç¥' :
                                      poi.category === 'store' ? 'üè™' : 'üì∏';
                      const distLabel = useMiles
                        ? `${kmToMi(poi.distanceKm).toFixed(1)} mi`
                        : `${poi.distanceKm.toFixed(1)} km`;

                      return (
                        <div
                          key={poi.id}
                          className={`mini-card ${poi.isPlannedStop ? 'planned' : ''} ${poi.isPossibleStop ? 'possible' : ''} ${expandedStopId === poi.id ? 'expanded' : ''}`}
                          onClick={() => setExpandedStopId(expandedStopId === poi.id ? null : poi.id)}
                        >
                          <div className="mini-card-header">
                            <span>{iconHtml}</span>
                            <span className="mini-card-name" title={poi.name}>{poi.name}</span>
                          </div>
                          <div className="mini-card-meta">
                            {formatTime(poi.eta)} ‚Ä¢ {distLabel}
                            {poi.distanceOffRoute >= 50 ? ` ‚Ä¢ ‚Üó${useMiles ? (mToFt(poi.distanceOffRoute) / 5280).toFixed(1) + 'mi' : (poi.distanceOffRoute / 1000).toFixed(1) + 'km'}` : ' ‚Ä¢ On Route'}
                          </div>
                          {poi.hoursInfo?.display && (
                            <div className="mini-card-hours">
                              <span className={poi.hoursInfo.isOpen === false ? 'closed' : ''}>
                                {poi.hoursInfo.isOpen === true ? '‚úì Open' : poi.hoursInfo.isOpen === false ? '‚úó Closed' : '‚è∞'}
                              </span>
                              {' ¬∑ '}{poi.hoursInfo.display}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            </section>
          )}

          {renderPoiPopover()}

          {routeData && (
            <div className="export-panel">
              <div className={`export-dropdown ${showExport ? 'open' : ''}`}>
                <div className="export-option" onClick={exportGPX}>
                  <div className="export-option-icon">üó∫Ô∏è</div>
                  <div>
                    <div style={{ fontWeight: '500' }}>GPX with Waypoints</div>
                    <div style={{ fontSize: '12px', color: '#6b7280' }}>For GPS devices</div>
                  </div>
                </div>
                <div className="export-option" onClick={exportPDF}>
                  <div className="export-option-icon">üìÑ</div>
                  <div>
                    <div style={{ fontWeight: '500' }}>PDF Trip Plan</div>
                    <div style={{ fontSize: '12px', color: '#6b7280' }}>Printable itinerary</div>
                  </div>
                </div>
              </div>
              <button
                className="btn btn-primary"
                onClick={() => setShowExport(!showExport)}
              >
                <Icons.Download />
                Export Plan
              </button>
            </div>
          )}

          {/* View Plan Floating Action Button */}
          <button
            className={`view-plan-fab ${showViewPlanButton ? 'visible' : ''}`}
            onClick={scrollToPlannedStops}
            title="View your planned stops"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
              <rect x="9" y="3" width="6" height="4" rx="1"/>
              <path d="M9 12h6M9 16h6"/>
            </svg>
            View Plan
            {Object.keys(plannedStops).length > 0 && (
              <span className="fab-count">{Object.keys(plannedStops).length}</span>
            )}
          </button>
        </div>
      );
    }

    console.log('RouteScout: About to render App...');
    try {
      ReactDOM.createRoot(document.getElementById('root')).render(
        <ErrorBoundary>
          <App />
        </ErrorBoundary>
      );
      console.log('RouteScout: App rendered successfully');
    } catch (err) {
      console.error('RouteScout: Render failed:', err);
      document.getElementById('root').innerHTML = '<div style="padding:40px;text-align:center;"><h2 style="color:#dc2626;">Failed to load RouteScout</h2><p>' + err.message + '</p></div>';
    }
  </script>
</body>
</html>
